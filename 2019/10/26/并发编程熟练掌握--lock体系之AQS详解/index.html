<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="并发编程熟练掌握--lock体系详解之AQS"><meta name="keywords" content="java-concurrency"><meta name="author" content="OnOne"><meta name="copyright" content="OnOne"><title>并发编程熟练掌握--lock体系详解之AQS | NoOneBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程熟练掌握–Lock体系详解"><span class="toc-number">1.</span> <span class="toc-text">并发编程熟练掌握–Lock体系详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock和-AbstractQueuedSynchronizer"><span class="toc-number">2.</span> <span class="toc-text">Lock和 AbstractQueuedSynchronizer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrent包结构"><span class="toc-number">2.1.</span> <span class="toc-text">concurrent包结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock简介"><span class="toc-number">3.</span> <span class="toc-text">Lock简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock接口的API"><span class="toc-number">3.1.</span> <span class="toc-text">Lock接口的API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初识AQS"><span class="toc-number">4.</span> <span class="toc-text">初识AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS中的模板方法设计模式"><span class="toc-number">4.1.</span> <span class="toc-text">AQS中的模板方法设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步组件以及AQS的功能实际上可以切分成两部分"><span class="toc-number">4.2.</span> <span class="toc-text">同步组件以及AQS的功能实际上可以切分成两部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入理解AQS"><span class="toc-number">5.</span> <span class="toc-text">深入理解AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步队列"><span class="toc-number">5.1.</span> <span class="toc-text">同步队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#独占锁"><span class="toc-number">5.2.</span> <span class="toc-text">独占锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#独占锁的获取-acquire"><span class="toc-number">5.3.</span> <span class="toc-text">独占锁的获取(acquire)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#独占锁的释放-release"><span class="toc-number">5.4.</span> <span class="toc-text">独占锁的释放 release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可中断获取锁-acquireInterruptibly方法"><span class="toc-number">5.5.</span> <span class="toc-text">可中断获取锁 (acquireInterruptibly方法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超时等待式获取锁-tryAcquireNanos-方法"><span class="toc-number">5.6.</span> <span class="toc-text">超时等待式获取锁 (tryAcquireNanos()方法)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享锁"><span class="toc-number">6.</span> <span class="toc-text">共享锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享锁的获取-acquireShared"><span class="toc-number">6.1.</span> <span class="toc-text">共享锁的获取 (acquireShared())</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共享锁的释放-releaseShared-方法"><span class="toc-number">6.2.</span> <span class="toc-text">共享锁的释放 (releaseShared()方法)</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560457003474&amp;di=6832c808a533625921e698bee88bbdb0&amp;imgtype=0&amp;src=http%3A%2F%2Fimg08.oneniceapp.com%2Fupload%2Favatar%2F2018%2F05%2F05%2Faba7e29327a27abfcb1e525f623934ee.jpg"></div><div class="author-info__name text-center">OnOne</div><div class="author-info__description text-center">Happiness is only real when shared!</div><div class="follow-button"><a href="https://github.com/ahang9524">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">23</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NoOneBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">并发编程熟练掌握--lock体系详解之AQS</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技能树/">技能树</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="并发编程熟练掌握–Lock体系详解"><a href="#并发编程熟练掌握–Lock体系详解" class="headerlink" title="并发编程熟练掌握–Lock体系详解"></a>并发编程熟练掌握–Lock体系详解</h2><h2 id="Lock和-AbstractQueuedSynchronizer"><a href="#Lock和-AbstractQueuedSynchronizer" class="headerlink" title="Lock和 AbstractQueuedSynchronizer"></a>Lock和 AbstractQueuedSynchronizer</h2><h3 id="concurrent包结构"><a href="#concurrent包结构" class="headerlink" title="concurrent包结构"></a>concurrent包结构</h3><p><img src="https://ftp.bmp.ovh/imgs/2019/12/c50286e63d990320.png" alt="concurrent"></p>
<h2 id="Lock简介"><a href="#Lock简介" class="headerlink" title="Lock简介"></a>Lock简介</h2><p>concurrent包有两个子包, locks 和 amtomic。之前通过并发关键字synchronized这篇博客已经对锁有所了解,锁是用来控制多个线程来访问共享资源的方式，也就是一个锁能防止多个线程同时访问同一个共享资源。 在Lock出现之前，jdk1.5之前程序员都是通过synchronized关键字来控制多个线程访问共享资源的。 那么jdk1.5之后 lock的出现和 synchronized有什么不同呢：synchronized关键字加锁解锁是通过隐式的方式实现，程序员不用去关系加锁解锁的步骤。而lock提供了锁的获取和释放的接口,可中断的获取锁以及超时获取锁。 通常显示获取锁的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#125; finnally &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remarks: synchronized同步块执行完成或者遇到异常情况锁会自动释放，而lock必须调用unlock()方式释放锁，因此在finally块中释放锁。 同时不要把获取锁的过程写在try块中，因为如果再获取锁时发生了异常,异常抛出的同时锁会被无故释放掉。</code></p>
<h3 id="Lock接口的API"><a href="#Lock接口的API" class="headerlink" title="Lock接口的API"></a>Lock接口的API</h3><p><a href="https://imgse.com/i/QgQfJO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/13/QgQfJO.md.png" alt="lockAPI"></a><br>lock接口的五个方法，那么有哪些类实现了Lock接口呢？就先从最熟悉的 ReentrantLock来说吧：建议读者先看一下ReentrantLock的源码, 会很快的发现ReentrantLock的实现其实都来自静态内部类 Sync中的方法, 而Sync类继承了AbstractQueuedSynchronizer(同步器)。<br><img src="https://s2.ax1x.com/2019/12/13/Qg1Fud.png" alt="lockSync"></p>
<h2 id="初识AQS"><a href="#初识AQS" class="headerlink" title="初识AQS"></a>初识AQS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Provides a framework for implementing blocking locks and related</span><br><span class="line">synchronizers (semaphores, events, etc) that rely on</span><br><span class="line">first-in-first-out (FIFO) wait queues.  This class is designed to</span><br><span class="line">be a useful basis for most kinds of synchronizers that rely on a</span><br><span class="line">single atomic &#123;@code int&#125; value to represent state. Subclasses</span><br><span class="line">must define the protected methods that change this state, and which</span><br><span class="line">define what that state means in terms of this object being acquired</span><br><span class="line">or released.  Given these, the other methods in this class carry</span><br><span class="line">out all queuing and blocking mechanics. Subclasses can maintain</span><br><span class="line">other state fields, but only the atomically updated &#123;@code int&#125;</span><br><span class="line">value manipulated using methods &#123;@link #getState&#125;, &#123;@link</span><br><span class="line">#setState&#125; and &#123;@link #compareAndSetState&#125; is tracked with respect</span><br><span class="line">to synchronization.</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Subclasses should be defined as non-public internal helper</span><br><span class="line">classes that are used to implement the synchronization properties</span><br><span class="line">of their enclosing class.  Class</span><br><span class="line">&#123;@code AbstractQueuedSynchronizer&#125; does not implement any</span><br><span class="line">synchronization interface.  Instead it defines methods such as</span><br><span class="line">&#123;@link #acquireInterruptibly&#125; that can be invoked as</span><br><span class="line">appropriate by concrete locks and related synchronizers to</span><br><span class="line">implement their public methods.</span><br></pre></td></tr></table></figure>

<p>源码AbstractQueuedSynchronizer类的注释。AQS是用来构建锁和其他同步组件的基础框架, 实现是依赖于FIFO的同步队列和一个原子的int类型的成员变量来表示同步状态。<code>AQS的子类必须重写AQS的几个protected方法，如tryAcquire()、setState()方法</code>。其他方法主要实现队列和阻塞机制。 <code>状态的更新使用getState,setState,compareAndSetState方法</code><br>AQS(同步器)既支持独占式获取同步状态, 又支持共享式获取同步状态，后面会详细介绍这种方式获取同步方式的实现。<code>AQS是实现锁的关键,在锁的实现中聚合同步器。两者的关系是：锁是面向使用者的,定义了锁的交互接口(如获取、释放),隐藏了实现的细节。而AQS是面向实现者的, 它简化了锁的实现方式, 屏蔽了同步状态的管理、线程的排队、等待和唤醒的底层操作。</code></p>
<h3 id="AQS中的模板方法设计模式"><a href="#AQS中的模板方法设计模式" class="headerlink" title="AQS中的模板方法设计模式"></a>AQS中的模板方法设计模式</h3><p>AQS使用了模板方法的设计模式, 将一些方法开放给子类重写，而同步器给同步组件所提供的模板方法会去调用被子类重写的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">      throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ReentrantLock中的NonfairSync 会重写该方法为:</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AQS中的模板方法acquire()</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承了AQS的NonfairSync调用模板方法acquire时就会调用已经被NonfairSync重写的tryAcquire方法。这就是使用AQS的方式。  </p>
<ol>
<li>同步组件(锁、CountDownLatch等)的实现依赖于同步器AQS, 在同步器实现中, 使用AQS的方式被推荐定义继承AQS的静态内部类。  </li>
<li>AQS使用的是模板方法设计模式, AQS的protected修饰的方法需要由继承AQS子类进行重写实现。</li>
<li>AQS负责同步状态管理、线程排队、等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义。</li>
<li>在重写AQS的方式时，使用AQS提供的getState()、setState()、compareAndSetState()方法进行修改同步状态。  </li>
</ol>
<p>其中AQS重写的方法如下：<br><img src="https://s2.ax1x.com/2020/02/15/3SA10g.png" alt></p>
<p>AQS提供的模板方法：<br><img src="https://s2.ax1x.com/2020/02/15/3SFvxf.png" alt><br>大致可以分成三类:<br>1.独占式获取和释放锁<br>2.共享式获取和释放锁<br>3.查询同步队列中等待线程的情况  </p>
<h3 id="同步组件以及AQS的功能实际上可以切分成两部分"><a href="#同步组件以及AQS的功能实际上可以切分成两部分" class="headerlink" title="同步组件以及AQS的功能实际上可以切分成两部分"></a>同步组件以及AQS的功能实际上可以切分成两部分</h3><p>1.同步组件实现者的角度<br>通过重写方法： 独占式 –&gt; {tryAcquire()、 tryRelease()} , 共享式 –&gt; {tryAcquireShared()、 tryReleaseShared()} <code>来告诉AQS怎么判断当前同步状态是否成功获取和是否成功施放</code></p>
<p>2.AQS的角度<br>对应AQS，只需要同步组件返回ture/false 即可， 因为AQS会对true 和 false 会有不同的操作。 ture会认为当前线程获取同步状态成功直接返回，而false的话就AQS会执行将当前线程插入同步队列中的一系列操作。</p>
<h2 id="深入理解AQS"><a href="#深入理解AQS" class="headerlink" title="深入理解AQS"></a>深入理解AQS</h2><p><code>brief description： 本小节主要通过AQS的同步队列、独占锁和共享锁的源码来分析。</code><br>在同步组件的实现中, AQS是核心。 通过使用AQS提供的模板方法来实现同步语义。AQS则实现了对 <code>同步状态的管理、对阻塞线程进行排队、等待通知</code>等一些底层的实现处理。</p>
<h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>当多个线程去请求共享资源的时候，只有1个线程会占用该共享资源，其他请求该资源的线程就会被阻塞从而进入同步队列中。下面我们来分析一下同步队列的数据结构吧。<br>两种最基本的数据结构 数组和链表(基本是所有数据结构的基础), AQS的同步队列的底层就是通过链表来实现的。当我们还没有看AQS源码的时候，心中相比是产生了一些疑惑：1.节点的数据结构是什么样子的 2.是单向链表还是双向链表更或是环形链表<br>3.有无头结点。<br>我们找到AQS对应的源码, 发现了AQS有一个静态内部类Node. 其中就有这样一些属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line"></span><br><span class="line">volatile int waitStatus //节点状态</span><br><span class="line">volatile Node prev //当前节点/线程的前驱节点</span><br><span class="line">volatile Node next; //当前节点/线程的后继节点</span><br><span class="line">volatile Thread thread;//加入同步队列的线程引用</span><br><span class="line">Node nextWaiter;//等待队列中的下一个节点</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中节状态有以下这些:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int CANCELLED =  1//节点从同步队列中取消</span><br><span class="line">int SIGNAL    = -1//后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；</span><br><span class="line">int CONDITION = -2//当前节点进入等待队列中</span><br><span class="line">int PROPAGATE = -3//表示下一次共享式同步状态获取将会无条件传播下去</span><br><span class="line">int INITIAL = 0;//初始状态</span><br></pre></td></tr></table></figure>

<p>看了AQS的源码我们就可以回答上面我们提出的疑惑了。 AQS是一个双向链表，其节点的数据结构就是Node类的属性值，有头节点。下面通过一个demo来深入了解AQS的同步队列情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LockDemo &#123;</span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(10000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo中开启了5个线程,并且每个线程尝试获取锁然后slepp 10s。通过模拟让线程睡眠10s是为了让获取到锁的线程不立马释放锁这样其他线程获取锁的时候就会阻塞从而进入了同步队列中。通过debug可以看出，当Thread-4 获取锁失败后进入同步时：<br><img src="https://s2.ax1x.com/2020/02/15/3SAg91.png" alt="AQS-syncQueeue">  </p>
<p>从截图中可以看出Thread0成功获取了锁，而Thread1,2,3,4阻塞进入同步队列中。每个节点有两个域：prev和next。 并且每个节点用来保存同步状态失败的的线程应用以及等待状态信息。另外AQS中有两个重要的成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile Node head;</span><br><span class="line">private transient volatile Node tail;</span><br></pre></td></tr></table></figure>

<p>可以看出AQS实际上通过头尾指针来管理同步队列，同时实现包括获取锁失入队，释放锁时对同步队列中的线程进行通知等核心方法。其示意图如下：<br><img src="https://s2.ax1x.com/2020/02/15/3SAhnO.png" alt="AQS-Queeue"></p>
<p>通过上述看源码和debug的方法，我们可以清楚的知道：<br>1.节点的数据结构，即AQS的静态内部类Node，节点的等待状态的信息。<br>2.同步队列是一个双向队列，AQS通过持有头尾指针管理同步状态。</p>
<p>同步队列是为了在获取锁失败的时候进行入队操作，以及获取锁成功的时候出队操作。</p>
<h3 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h3><h3 id="独占锁的获取-acquire"><a href="#独占锁的获取-acquire" class="headerlink" title="独占锁的获取(acquire)"></a>独占锁的获取(acquire)</h3><p>通过看AQS的源码和上述demo，当lock.lock()方法获取独占锁，获取失败就将当前线程加入同步队列中，获取成功则线程执行。 而lock实际上会调用AQS的<code>acquire()</code>. AQS的acquire()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       //获取锁成功则返回， 获取锁失败则先调用addWaiter()方法再调用acquireQueued()方法</span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们继续分析源码，那么获取锁失败将当前线程加入同步队列的奥秘就藏在了 addWaiter()方法和 acquireQueued()方法中了。那我们就继续看源码咯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">        //将当前线程构建成Node</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        Node pred = tail;</span><br><span class="line">        //当前节点是否是尾节点</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">          // 不是尾节点的话，就将当前节点以尾插法插入同步队列中</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //同步队列的尾节点为空的话，那么就表示当前线程是第一个加入同步队列中进行等待的线程</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>addWaiter源码可知：可以总结为两部分–&gt;<br>1.当前同步队列的尾节点为空的时候，直接调用enq()方法。<br>2.当前同步队列的尾节点不为空的时候, 先将当前线程构建的节点的prev指向尾节点，然后通过CASTail 尾插法的方式插入到同步队列中。但是如果多个线程同时获取锁失败进入addWaiter方法的时候，并尾节点不为空。 那么只有1个线程的CASTail操作是成功的，失败的则会继续在enq里面处理。那么我们继续来看enq()的源码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           if (t == null) &#123; // Must initialize</span><br><span class="line">             //同步队列为空，也就是需要构建头结点(考虑到并发场景,所以需要CASHead)</span><br><span class="line">               if (compareAndSetHead(new Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">             //尾插入, 处理两类： 1.在addWaiter方法中的CASTail失败的线程 2.在上一部CASHead失败的线程 (采用自旋的手段)</span><br><span class="line">               node.prev = t;</span><br><span class="line">               if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   return t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过enq方法可知 AQS的同步队列是带头结点的。(带头结点的链表在入队和出队的操作会有更大的便捷性)。通过源码分析enq()方法可知:<br>1.当前线程是第一批加入同步队列时,调用compareAndSetHead方法来完成头结点的构建。<br>2.通过for(;;)自旋操作知道节点插入成功</p>
<p>通过分析了addWaiter方法可以知道获取独占式锁失败的线程 会被构建成node节点并且通过尾插法和自旋来入队。那么接下来就是同步队列中的节点(线程)会通过什么样的操作来保证自己能够获取独占式锁呢？ 带着这个问题我们来继续看 acquireQueued方法的源码(排队获取锁的过程)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">       boolean failed = true;</span><br><span class="line">       try &#123;</span><br><span class="line">           boolean interrupted = false;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">             //获取当前节点的前驱节点</span><br><span class="line">               final Node p = node.predecessor();</span><br><span class="line">               //当前节点是头结点且成功获取了同步状态</span><br><span class="line">               if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                 //队列的头结点应用指向当前节点</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   //释放前驱节点</span><br><span class="line">                   p.next = null; // help GC</span><br><span class="line">                   failed = false;</span><br><span class="line">                   return interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               //当前节点不是头结点 或 获取锁失败. 线程进入等待状态--&gt; 等待获取独占锁</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>有acquireQueued的源码可知，这是个自旋的过程 for(;;). 先获取到当前线程的前驱节点(线程)，如果前驱节点是头结点且获取同步状态成功的时候，当前节点就能获取到锁。反之则获取锁失败进入等待状态。<br><img src="https://s2.ax1x.com/2020/02/16/3SVERI.png" alt="AQS-Queued-2"><br>继续来看获取锁成功的节点出队的逻辑– setHead方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = null;</span><br><span class="line">        node.prev = null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过下面图可以可以直观的看到过程:<br><img src="https://s2.ax1x.com/2020/02/16/3SVmsf.png" alt="AQS-queued3"></p>
<p>我们继续来看获取锁失败的逻辑,由源码可知获取锁失败回去调用shouldParkAfterFailedAcquire方法, 继续来跟进看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">      //获取当前节点的前驱节点的状态</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取锁失败调用的shouldParkAfterFailedAcquire方法，看源码可知使用CAS将节点的状态由INITIAL设置成SINGAL.表示当前线程阻塞。 当compareAndSetWaitStatus设置失败则说明shouldParkAfterFailedAcquire返回false。 然后会在acquireQueued方法中for(;;)自旋,直到compareAndSetWaitStatus设置节点状态为SINGNAL时返回ture 才会继续执行后续的 parkAndCheckInterrupt方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">       //使该线程阻塞</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以通过源码我们可以知道acquireQueued方法在自旋主要做了两件事：<br>1.如果当前节点的前驱节点是头结点且获取同步状态成功的话，当前线程能获取锁,方法执行结束退出。<br>2.获取锁失败的话, 先将节点状态设置成SIGNAL,然后调用LookSupport.park使得线程阻塞。<br><img src="https://s2.ax1x.com/2020/01/15/lOQoTK.png" alt="AQS-acquire"></p>
<h3 id="独占锁的释放-release"><a href="#独占锁的释放-release" class="headerlink" title="独占锁的释放 release"></a>独占锁的释放 release</h3><p>下面我们来继续看独占锁的释放。还是通过源码的方式来分析: show me the code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">       if (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>独占锁的释放代码就很好理解了，释放锁成功的话则判断头结点，当头结点不为空且头结点的状态不是初始状态的时候则唤醒头结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Wakes up node&apos;s successor, if one exists.</span><br><span class="line">     *</span><br><span class="line">     * @param node the node</span><br><span class="line">     */</span><br><span class="line">    private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">         * fails or if status is changed by waiting thread.</span><br><span class="line">         */</span><br><span class="line">        int ws = node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Thread to unpark is held in successor, which is normally</span><br><span class="line">         * just the next node.  But if cancelled or apparently null,</span><br><span class="line">         * traverse backwards from tail to find the actual</span><br><span class="line">         * non-cancelled successor.</span><br><span class="line">         */</span><br><span class="line">         //头结点的下一个节点</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        //当头节点的下一个节点为空或者状态是 1(cancel)的时候,从尾往前找到一个没有被去掉的节点并唤醒</span><br><span class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s = null;</span><br><span class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                if (t.waitStatus &lt;= 0)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s != null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过源码以及源码给的注释, 我们就很清晰的知道了tryRlease释放独占锁的内部实现了。先通过判断头结点的状态来进行唤醒下一个节点的状态(唤醒策略写在了上述源码的注释中了)。</p>
<p>通过源码分析以及流程图相比我们已经很清楚的理解了独占锁的获取和释放的内部原理了。做一个小结：<br><code>独占锁的获取过程的在获取同步状态失败后, 会先调用addWaiter方法将线程构建成一个Node节点,方法的核心思路是 判断同步队列尾节点是否为空来进行尾插还是直接enq()入队，enq的核心思想是自旋来保证插入队列成功。在入队成功后
回去调用acquireQueued方法来让同步队列中的线程获取到同步状态。核心思想是自旋并且如果当前节点的前驱节点是头结点且获取同步状态成功的话，则头结点出队当前节点作为新的头结点，否则的话将当前节点的状态设置成singal并用unpark方法
将当前线程设置成阻塞状态。 tryRelease方法独占锁的时候的核销逻辑就是唤醒下一个节点。</code></p>
<h3 id="可中断获取锁-acquireInterruptibly方法"><a href="#可中断获取锁-acquireInterruptibly方法" class="headerlink" title="可中断获取锁 (acquireInterruptibly方法)"></a>可中断获取锁 (acquireInterruptibly方法)</h3><p>lock相对于synchronized的便捷特性，其中就有响应中断以及超时等特性。 我们依旧通过分析源码的方式来掌握响应中断是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        //线程获取锁失败</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取锁失败的时候会调用doAcquireInterruptibly，继续跟进看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    //将节点插入到同步队列中</span><br><span class="line">    final Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //获取锁出队</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                //线程中断抛异常</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和上述分析acquireQueued的源码基本一样。唯一的区别在于acquireQueued方法在阻塞线程后将interrupted设置成ture，这里是直接抛出了中断的异常。即线程阻塞时该线程被中断，抛出中断异常。</p>
<h3 id="超时等待式获取锁-tryAcquireNanos-方法"><a href="#超时等待式获取锁-tryAcquireNanos-方法" class="headerlink" title="超时等待式获取锁 (tryAcquireNanos()方法)"></a>超时等待式获取锁 (tryAcquireNanos()方法)</h3><p>lock.tryLock(timeout,TimeUnit)是超时等待获取锁的api方法。会存在三种情况：<br>1.在规定的时间内返回值。<br>2.当前线程在超时时间内被中断。<br>3.超时时间结束，仍然未获取到锁返回false。</p>
<p>最直观的方法来了解原理就是看源码。show me the code :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        //实现超时等待的效果.当tryacqure获取同步状态失败时候才会走超时等待获取锁</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取同步状态失败后才会执行doAcquireNanos方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private boolean doAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (nanosTimeout &lt;= 0L)</span><br><span class="line">        return false;</span><br><span class="line">    //1. 根据超时时间和当前时间计算出截止时间</span><br><span class="line">    final long deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    final Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            //2. 当前线程获得锁出队列</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // 3.1 重新计算超时时间</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            // 3.2 已经超时返回false</span><br><span class="line">            if (nanosTimeout &lt;= 0L)</span><br><span class="line">                return false;</span><br><span class="line">            // 3.3 线程阻塞等待</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                //没有超时且时间范围在1s内</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">            // 3.4 线程被中断抛出被中断异常</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超时等待获取锁的逻辑和可中断获取锁逻辑基本一致。但是引入了超时时间的概念。先在刚执行的时候计算了截止时间。然后在当前线程没有成功获取锁 重新计算超时时间，如果已经超时就返回false。 如果没有超时就自旋的方式将当前线程设置成signal并且截止时间在1s内则进行阻塞。</p>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h3 id="共享锁的获取-acquireShared"><a href="#共享锁的获取-acquireShared" class="headerlink" title="共享锁的获取 (acquireShared())"></a>共享锁的获取 (acquireShared())</h3><p>既然已经攻克了独占锁的源码, 相比对共享锁也很有信心了。talk is cheap， show me the code。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquireShared的返回值大于等于0的时候表示获取锁成功，小于0的时候表示获取锁失败。那么源码则表示获取锁失败的时候会执行doAcquireShared方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Acquires in shared uninterruptible mode.</span><br><span class="line">    * @param arg the acquire argument</span><br><span class="line">    */</span><br><span class="line">   private void doAcquireShared(int arg) &#123;</span><br><span class="line">       final Node node = addWaiter(Node.SHARED);</span><br><span class="line">       boolean failed = true;</span><br><span class="line">       try &#123;</span><br><span class="line">           boolean interrupted = false;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               final Node p = node.predecessor();</span><br><span class="line">               if (p == head) &#123;</span><br><span class="line">                   int r = tryAcquireShared(arg);</span><br><span class="line">                   if (r &gt;= 0) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = null; // help GC</span><br><span class="line">                       if (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = false;</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码主逻辑和独占锁获取过程几乎一样。自旋结束调点是当前节点的前驱节点是头结点且获取共享锁的同步状态成功。</p>
<h3 id="共享锁的释放-releaseShared-方法"><a href="#共享锁的释放-releaseShared-方法" class="headerlink" title="共享锁的释放 (releaseShared()方法)"></a>共享锁的释放 (releaseShared()方法)</h3><p>不多说了，直接上菜</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核销逻辑是成功获取同步状态后,执行的doReleaseShared方法</p>
<pre><code>/**
   * Release action for shared mode -- signals successor and ensures
   * propagation. (Note: For exclusive mode, release just amounts
   * to calling unparkSuccessor of head if it needs signal.)
   */
  private void doReleaseShared() {
      /*
       * Ensure that a release propagates, even if there are other
       * in-progress acquires/releases.  This proceeds in the usual
       * way of trying to unparkSuccessor of head if it needs
       * signal. But if it does not, status is set to PROPAGATE to
       * ensure that upon release, propagation continues.
       * Additionally, we must loop in case a new node is added
       * while we are doing this. Also, unlike other uses of
       * unparkSuccessor, we need to know if CAS to reset status
       * fails, if so rechecking.
       */
      for (;;) {
          Node h = head;
          if (h != null &amp;&amp; h != tail) {
              int ws = h.waitStatus;
              if (ws == Node.SIGNAL) {
                  if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                      continue;            // loop to recheck cases
                  unparkSuccessor(h);
              }
              else if (ws == 0 &amp;&amp;
                       !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                  continue;                // loop on failed CAS
          }
          if (h == head)                   // loop if head changed
              break;
      }
  }</code></pre><p>共享锁的释放和独占锁的释放的最大的区别在于共享锁是要支持多个线程并发的去释放同步状态,所以需要加上cas来保证,cas失败后就continue在自旋中进行下一次尝试。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">OnOne</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://nooneblog.com/2019/10/26/并发编程熟练掌握--lock体系之AQS详解/">https://nooneblog.com/2019/10/26/并发编程熟练掌握--lock体系之AQS详解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-concurrency/">java-concurrency</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/11/09/并发编程熟练掌握--lock体系详解之ReentrantLock、ReentrantReadWriteLock详解/"><i class="fa fa-chevron-left">  </i><span>并发编程熟练掌握--lock体系详解之ReentrantLock、ReentrantReadWriteLock详解</span></a></div><div class="next-post pull-right"><a href="/2019/10/15/并发编程熟练掌握--并发关键字/"><span>并发编程熟练掌握--并发关键字</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By OnOne</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://nooneblog.com/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>