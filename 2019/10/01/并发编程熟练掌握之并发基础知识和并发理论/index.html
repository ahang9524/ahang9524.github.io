<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="并发编程熟练掌握之并发基础知识和并发理论"><meta name="keywords" content="java-concurrency"><meta name="author" content="OnOne"><meta name="copyright" content="OnOne"><title>并发编程熟练掌握之并发基础知识和并发理论 | NoOneBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程熟练掌握之并发基础知识和并发理论"><span class="toc-number">1.</span> <span class="toc-text">并发编程熟练掌握之并发基础知识和并发理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">2.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发编程的优缺点"><span class="toc-number">2.1.</span> <span class="toc-text">并发编程的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的状态和基本操作"><span class="toc-number">2.2.</span> <span class="toc-text">线程的状态和基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发理论"><span class="toc-number">3.</span> <span class="toc-text">并发理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java内存模型和happen-before原则"><span class="toc-number">3.1.</span> <span class="toc-text">java内存模型和happen-before原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java内存模型"><span class="toc-number">3.2.</span> <span class="toc-text">java内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM抽象结构模型"><span class="toc-number">3.3.</span> <span class="toc-text">JMM抽象结构模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重排序"><span class="toc-number">3.4.</span> <span class="toc-text">重排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#as-if-serial"><span class="toc-number">3.4.1.</span> <span class="toc-text">as-if-serial</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before规则"><span class="toc-number">3.5.</span> <span class="toc-text">happens-before规则</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560457003474&amp;di=6832c808a533625921e698bee88bbdb0&amp;imgtype=0&amp;src=http%3A%2F%2Fimg08.oneniceapp.com%2Fupload%2Favatar%2F2018%2F05%2F05%2Faba7e29327a27abfcb1e525f623934ee.jpg"></div><div class="author-info__name text-center">OnOne</div><div class="author-info__description text-center">Happiness is only real when shared!</div><div class="follow-button"><a href="https://github.com/ahang9524">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NoOneBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">并发编程熟练掌握之并发基础知识和并发理论</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技能树/">技能树</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="并发编程熟练掌握之并发基础知识和并发理论"><a href="#并发编程熟练掌握之并发基础知识和并发理论" class="headerlink" title="并发编程熟练掌握之并发基础知识和并发理论"></a>并发编程熟练掌握之并发基础知识和并发理论</h2><p><code>remarks: 最近在看 《java并发编程艺术》这本书，刚好工作也有一年半了，工作中也经常使用到线程池。所以想趁着看完 并发编程艺术
这本书，写一个比较完整的关于多线程的原理的笔记，来提升理解和对并发编程的认知。 如有任何疑问，欢迎邮件和我沟通：353113305@qq.com</code></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="并发编程的优缺点"><a href="#并发编程的优缺点" class="headerlink" title="并发编程的优缺点"></a>并发编程的优缺点</h3><ul>
<li><p>为什么要用到并发？<br>从我小时候开始接触电脑开始到现在，已经经历了从单核到4核到8核CPU的升级。在追求极致性能的情况下，往往我们在编程的时候需要用到多线程来提升接口的响应速度。即为什么要用到并发？ 因为并发编程在如今多核CPU的硬件设备，可以大幅度的提升我们代码性能，提升接口的响应速度。<br>另外在我这一年半的工作中发现，很多时候在面对比较复杂的业务模型的时候，并不需要串行的一步一步走下去，很多时候其实是可以异步去执行很多业务的，这时候并发编程就表现就更为突出了。</p>
</li>
<li><p>并发编程的缺点  </p>
</li>
</ul>
<p>(1) <strong>频繁的上下文切换</strong><br>多线程是通过线程轮流切换并分配获得CPU的时间片来实现的。 而CPU分配给各个线程的时间片是很短的，每个CPU是通过不断切换时间片，让我们觉得是多个线程是在同时执行的。 而每次切换时间片的时候，需要保存当前的状态，以便能切回来，这个切换是十分消耗性能的。过于频繁的切换线程会无法发挥出并发编程的优势(线程池也是在这样的考虑下诞生的)。<br>为了减少线程上下文的切换，可以采用： 无锁编程、CAS算法、使用最少线程、协程。  </p>
<ul>
<li>无锁编程：多线程竞争锁时，会引起线程切换, 可以用一些方法来规避这种线程切换来带的性能损耗。 如通过请求参数中的id来进行Hash取模分段，不同线程处理不同段数据。  </li>
<li>CAS算法： 利用Atomic下使用的CAS算法来更新数据。使用了乐观锁，可有效的减少一部分不必要的锁竞争引起的上下文切换。  </li>
<li>使用最小线程：避免创建无用的线程, 比如任务很少, 就没必要去创建很多的线程。  </li>
<li>协程：在单线程中实现多任务调度, 并在单线程里维护多个任务间的切换<br><code>remarks: 多线程不一定会加快编程速度，因为上下文切换也是相对比较耗时的操作。但是如业务开发中涉及到异步插入数据这种或者是 异步查询然后join这种还是能提高不少相应速度的。</code>  </li>
</ul>
<p>(2) <strong>线程安全问题</strong></p>
<ul>
<li>并发编程中很值得关注的就是死锁。一旦产生死锁系统就造成系统功能不可用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void deadLock() &#123;</span><br><span class="line">      Thread threadA = new Thread(new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              synchronized (A) &#123;</span><br><span class="line">                  log.info(&quot;threadA Sync-&gt;A&quot;);</span><br><span class="line">                  try &#123;</span><br><span class="line">                      Thread.currentThread().sleep(2000);</span><br><span class="line">                      synchronized (B) &#123;</span><br><span class="line">                          log.info(&quot;threadA sync-&gt;B&quot;);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  log.error(&quot;e&quot;,e);</span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread threadB = new Thread(new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              synchronized (B) &#123;</span><br><span class="line">                  log.info(&quot;threadB Sync-&gt;B&quot;);</span><br><span class="line">                  synchronized (A) &#123;</span><br><span class="line">                      log.info(&quot;threadB Sync-&gt;A&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      threadA.start();</span><br><span class="line">      threadB.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如示例的死锁demo，线程A占用了资源A 并等待被线程B释放的资源B。 线程B占用了资源B 并等待被线程A释放的资源A。 这样就造成了线程A和<br>线程B相互等待，造成死锁。</p>
<ul>
<li>易混淆的几个概念<br>(1) 同步 VS 异步<br>同步和异步指的是一次方法调用。同步方法调用开始，被调用方法必须等待同步方法执行完，才能继续执行后续代码。而异步方法调用开始，被调用发无需等待就可以继续执行后续代码，当被调用的方法完成后会通知调用方。举个栗子，购物大家都有经历过，去超时购物时候，如果一件物品没了，这时候导购员就需要去仓库确认是否还有存货，有的话就回去仓库把物品拿过来，然后你才能付款，这个可以理解成同步过程。 然后网购的话，只需要加入购物车然后付款就行，无需等待，当货无到了之后通知去取就好，这个可以理解成异步。<br>(2) 并发 VS 并行<br>并行只会发生在多核系统之中。并发是指多个任务交替进行，而并行是真正意义上的“同时进行”。且并行只会在多核CPU的场景下存在。因为多线程的实现是通过轮流切换并获取到CPU的时间片来实现的。<br>(3) 阻塞 VS 非阻塞<br>阻塞和非阻塞用来形容多线程间的相互影响。比如一个线程获取到了一个临界资源，其他想获取这个临界资源的线程就必须进入等待状态知道该资源被释放，这种就是阻塞。而非阻塞强调没有一个线程可以阻塞其他线程，所有程序都可以尝试继续运行。<br>(4) 临界值<br>临界值用来表示一种公共资源或者说是共享数据。临界值可以被多个线程使用，但是一旦有一个线程占有这个资源后，其他线程想使用这个资源就必须等待直到这个临界值被释放。  </li>
</ul>
<h3 id="线程的状态和基本操作"><a href="#线程的状态和基本操作" class="headerlink" title="线程的状态和基本操作"></a>线程的状态和基本操作</h3><h2 id="并发理论"><a href="#并发理论" class="headerlink" title="并发理论"></a>并发理论</h2><h3 id="java内存模型和happen-before原则"><a href="#java内存模型和happen-before原则" class="headerlink" title="java内存模型和happen-before原则"></a>java内存模型和happen-before原则</h3><p>在线程的状态和基本操作中整理一下线程的基本用法，但是只是直到怎么使用的话就很容易出现线程安全的问题。什么是线程安全：wiki: <a href="https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">线程安全</a>. 而出现线程安全的问题一般是因为 <code>主内存和工作内存数据不一致</code>和<code>重排序</code>导致的。而要理解这两个引子，就得先理解好java的内存模型(JMM)。</p>
<h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><p>在并发编程中，有2个关键问题: 1.线程间如何通信 2.线程之间如何同步。<br>通信是指线程之间以何种机制来交换信息，主要分两种：<code>共享内存</code> 和 <code>消息传递</code>。 而java内存模型是<code>共享内存的并发模型</code>,线程之间主要通过读-写共享变量来完成隐式通信。<br>共享变量指的是线程共享的数据区内的值(方法区、堆区。如果忘记了jvm的知识的同学可以看一下我的那篇”熟练掌握JVM”)。如实例域(堆区)、<br>静态域(方法区)和数组元素(堆区)。 而局部变量(栈区),方法定义参数和异常处理器参数不会在线程共享。 所以也只有共享数据才会出现线程安全问题。</p>
<h3 id="JMM抽象结构模型"><a href="#JMM抽象结构模型" class="headerlink" title="JMM抽象结构模型"></a>JMM抽象结构模型</h3><p>CPU的处理速度和主存的读写速度不在一个量级，为了平衡这个巨大差距，每个CPU都有缓存。因此，共享变量会先放进主存中，每个线程都有自己的工作内存，并且会把位于主内存中共享变量拷贝到自己的工作内存中，之后的读写操作均使用工作内存的变量副本，并且在某个时刻会把变量副本同步更新回主内存。<br><a href="https://imgchr.com/i/1OqBwj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/14/1OqBwj.png" alt="1OqBwj.png"></a><br>如JMM的共享内存的并发模型, 线程A和线程B进行通信的话会经历如下两步：<br>1.线程A先把主存的共享变量读如线程A的工作内存中并进行操作，之后会将数据重新写会主存中。<br>2.线程B从主存中读取最新的共享变量。 这样线程A和线程B就完成了隐形的通信。<br><code>remarks: 在上述描述中，如果线程A还没来得及将更新的值写入主存中，这时候线程B进行了读操作，这时候线程B读到的就不是最新的值，这时候就出现了 脏读 。 这时候就可以通过同步机制或者对共享变量加上volatile关键字, 使每次volatile变量都能强制刷新到主存中，从而对每个线程都是可见的</code></p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>为了提高性能，编译器以及处理器通常会对指令进行重排序。<br><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315b2b7b2a63e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="reSort"><br>1.编译器重排序。 编译器在不改变单线程程序的语义前提下，可以重新安排语句的执行顺序。<br>2.指令级重排序 。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序<br>3.内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。<br>上图，1是编译器重排序，2和3统称为处理器重排序。而重排序会引发线程安全的问题，如DCL，后面会详细写。 其中针对编译器重排序，JMM的编译器重排序规则会 <code>禁止一些特定类型的重排序</code>。而针对处理器重排序，编译器在生成指令序列的时候通过<code>插入内存屏障来禁止某些特殊指令的重排序</code>      </p>
<p>那么问题来了,什么时候不允许重排序呢？<br>有数据依赖的时候不允许重排序。继续举栗子:</p>
<pre><code>private int a = 1; //A
private int b = 2; //B
private int result = a*b //C</code></pre><p>这是一个简单的乘法计算逻辑，其中A和B的执行顺序对结果没有任何影响，因此编译器可以对A和B进行重排序。执行顺序可以是 A-&gt;B-C 还可以是B-&gt;A-&gt;C. 最终的结果都是2，即可以理解成A和B是没有数据依赖性的。 <code>数据依赖性的定义：</code>如果两个操作访问了同一个变量，其中有一个操作是写操作，此时这两个操作是有数据依赖性的。简单的组合包括：写后读、读后写、写后写 这三种操作都输具有数据依赖性的。编译器和处理器的重排序都会严格遵守数据的依赖性，即不会去改变有数据依赖性的两个操作的执行顺序。  </p>
<h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>as-if-serial 是指不管怎么重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能改变。编译器、runtime和处理器都必须遵循as-if-serial语义。 as-if-serial把单线程保护起来了，遵守as-if-serial语义的编译器，runtime和处理器为编写单线程程序的工程师创造了一个幻觉：单线程程序按照程序顺序来执行。 如上述A、B操作不存在数据依赖性因此可以重排序，而as-if-serial语义使工程师不必担心单线程中重排序带来的影响(程序的执行结果不能改变)，也无需担心内存可见性问题。</p>
<h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p><code>JMM可以通过happens-before关系向工程师提供跨线程的内存可见性保证</code>. happens-before用来形容两个操作之间的执行顺序的，这两个操作可以在同一个线程之中，也可以在不同线程之中。(继续到了举栗子环节: 如果线程A的写操作和线程B的读操作存在happens-before原则，尽管是在不同线程里的操作，但是JMM想工程师保证线程A的写操作是对线程B的读操作是可见的 )。<br>(1)如果一个操作happens-before另一个操作，则第一个操作结果对第二个操作可见，且第一个操作执行顺序在第二个操作之前。<br>(2)两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须按照happens-before关系制定的顺序来执行。如果是重排序后的结果和按照happens-before的结果一样，那么这种重排序并不非法。(也就是，JMM允许这种重排序)<br><code>remarks: 其中 (1)是JMM对工程师的承诺。 即工程师可以这样理解happens-before关系。如果A happens-before B，那么A的操作对B是可见的，且A的执行顺序是要先于B的执行顺序. (2)是JMM对编译器和处理器的约束规则。即JMM遵循一个原则：只要不改变程序的执行结果(),编译器和处理器想怎么优化都行。这么做的原因是因为其实工程师并不关心程序是否真被重排序，只关心最后的结果是否正确。</code>  </p>
<p><code>as-if-serial VS happens-before</code><br>1.as-if-serial是针对单线程的，而happens-before关系保证正确同步多线程程序结果不会改变。<br>2.as-if-serial是给编写单线程程序的工程师创造一个幻境: 单线程程序是按程序的顺序来执行的。happens-befores是给编写多线程的工程师创造了一个幻境：正确同步的多线程是按照happens-before制定顺序来执行的。<br>3.as-if-serial 和 happens-before 都是为了在不改变程序执行结果的前提下，尽可能的提高程序执行的并行度。  </p>
<p>具体8条规则：<br>1.程序顺序规则：一个线程中的每个操作，happens-before与该线程中后续操作。<br>2.监视器锁规则：对一个锁的解锁，happens-before于后续对这个锁的加锁。<br>3.volatile变量规则：对一个volatile域的写，happens-before这个volatile变量的读。<br>4.传递性： 如果A happens-before B， 且 B happens-before C 。 那么 A就 happens-before C。<br>5.start()规则： 如果线程A执行操作ThreadB.start() (在线程A里面启动线程B),那么 线程A的ThreadB.start()操作happens-before 线程B的任意操作。<br>6.join()规则:如果在线程A中执行ThreadB.join()并返回成功。那么线程B中的任意操作happens-before于线程A从ThreadB。join()操作成功返回。<br>7.程序中断规则：对线程interrupted()方法的调用先于被中断线程的代码检测到中断时间的发生。<br>8.对象finalize规则：一个对象的初始化完成(构造函数执行结束) happen-before 它的finalize()方法开始。  </p>
<p><code>思考</code><br>1.如果让我们来设计一个JMM会从哪些方面考虑，也可以说JMM承担了哪些功能呢？<br><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315b3505fe3170?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="JMM-Design"><br>其中JMM在中间层，包含了2个方面： 1. 内存模型 2.重排序和happens-before规则。 同时为了禁止特定类型的重排序会对编译器和处理器指令加以控制(编译器禁止对有数据依赖的操作进行重排序，处理器在将指令插入内存的时候加了内存屏障)。站在JMM的设计角度上，从两个维度考虑：<br>1.对开发工程师的易用性。即希望内存模型是易于理解的易于编程的，有一个基于一个强内存模型来编写代码。<br>2.编译器和处理器对内存模型的实现。 在不改变程序运行结果的前提下，对编译器和处理器的约束越少越好，这样就可以做更多的性能优化。  </p>
<p>基于上面2点，JMM的设计可以这样理解：<br><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315b40eb50a329?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="a">  </p>
<p>开发工程师只需要关系happens-before规则就行，然后由JMM根据happens-before对重排序做出一定的规约。其中分成 会改变程序执行结果的和不会改变程序执行结果的。<br>从上图可以看出如我们考虑的设计初衷是一致的：<br>(1)JMM向开发工程师提供的happens-before规则能满足工程师的需求。 JMM的happens-before规则不但简单易懂，而且向程序员提供了足够强的内存可见性。(内存可间性不一定真实存在。如上述操作 A happens-before B)<br>(2)JMM在不改变程序运行结果的前提下，对编译器和处理器的约束越少越好，即怎么优化好怎么来。我们继续举栗子：，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。<br>再如，如果编译器经过细致的分析后，认定一个volatile变量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</p>
<p>2.happens-before 和 JMM的关系  </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315b4732a0ed2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="JMM-Happen-before">  </p>
<p>3.由于JMM，多线程情况下可能会发生哪些问题呢？<br>我们了解了JMM是基于共享变量的内存模型，这种设计会可能出现”脏读”现象，这就属于了数据可见性的问题。 另外多线程中一个很经典的DCL(双重锁检查)，这就是需要禁止重排序的，还有多线程对的原子操作i++也会导致最后结果<br>不符预期(可用AotomicInteger来解决)。 总而言之，进行多线程开发的时候要考虑三个点 <strong>原子性、可见性、有序性</strong>。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">OnOne</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://nooneblog.com/2019/10/01/并发编程熟练掌握之并发基础知识和并发理论/">https://nooneblog.com/2019/10/01/并发编程熟练掌握之并发基础知识和并发理论/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-concurrency/">java-concurrency</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/10/12/新轻量级熔断技术 --Sentinel/"><i class="fa fa-chevron-left">  </i><span>新轻量级熔断技术选型--Sentinel源码解析</span></a></div><div class="next-post pull-right"><a href="/2019/09/08/java虚拟机熟练掌握之自动内存管理机制/"><span>java虚拟机熟练掌握之自动内存管理机制(基于JDK1.8)</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By OnOne</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://nooneblog.com/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>