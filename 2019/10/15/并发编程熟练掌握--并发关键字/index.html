<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="并发编程熟练掌握--并发关键字"><meta name="keywords" content="java-concurrency"><meta name="author" content="OnOne"><meta name="copyright" content="OnOne"><title>并发编程熟练掌握--并发关键字 | NoOneBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程熟练掌握–并发关键字Synchronized、Volatile、Final"><span class="toc-number">1.</span> <span class="toc-text">并发编程熟练掌握–并发关键字Synchronized、Volatile、Final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#彻底理解synchronized"><span class="toc-number">2.</span> <span class="toc-text">彻底理解synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized实现原理"><span class="toc-number">2.1.</span> <span class="toc-text">synchronized实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized优化"><span class="toc-number">2.2.</span> <span class="toc-text">synchronized优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#彻底理解volatile"><span class="toc-number">3.</span> <span class="toc-text">彻底理解volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#你真的需要了解final"><span class="toc-number">4.</span> <span class="toc-text">你真的需要了解final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final的简介"><span class="toc-number">4.1.</span> <span class="toc-text">final的简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final的具体使用场景"><span class="toc-number">4.2.</span> <span class="toc-text">final的具体使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程中的final关键字"><span class="toc-number">4.3.</span> <span class="toc-text">多线程中的final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么final引用不能从构造函数中”逸出”"><span class="toc-number">4.4.</span> <span class="toc-text">为什么final引用不能从构造函数中”逸出”</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560457003474&amp;di=6832c808a533625921e698bee88bbdb0&amp;imgtype=0&amp;src=http%3A%2F%2Fimg08.oneniceapp.com%2Fupload%2Favatar%2F2018%2F05%2F05%2Faba7e29327a27abfcb1e525f623934ee.jpg"></div><div class="author-info__name text-center">OnOne</div><div class="author-info__description text-center">Happiness is only real when shared!</div><div class="follow-button"><a href="https://github.com/ahang9524">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">21</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NoOneBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">并发编程熟练掌握--并发关键字</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技能树/">技能树</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="并发编程熟练掌握–并发关键字Synchronized、Volatile、Final"><a href="#并发编程熟练掌握–并发关键字Synchronized、Volatile、Final" class="headerlink" title="并发编程熟练掌握–并发关键字Synchronized、Volatile、Final"></a>并发编程熟练掌握–并发关键字Synchronized、Volatile、Final</h2><h2 id="彻底理解synchronized"><a href="#彻底理解synchronized" class="headerlink" title="彻底理解synchronized"></a>彻底理解synchronized</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronized implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int result = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(new Synchronized());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(&quot;result:&quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一篇我们已经知道了JMM是基于共享变量的内存模型，每个线程都有自己的工作内存，通过读写主存中的共享变量进行通信。而上述代码中我们可以很快的看出是有10个线程同时对 int result进行 ‘++’操作，<br>而没有保证每个线程的’++’操作是对其他线程可见的，最终的结果也必然不是 10*100000咯。那么怎么样才能得到我们最后想要的结果呢？ 如果每个线程都是串行的去读这个共享变量，这样就不会产生安全的问题了。<br>那么java关键字sychronized就具有使每个线程依次排队操作共享变量的功能。</p>
<p><code>remarks: 上述代码会有疑问，就是在单机(一台服务器中)用多线程(10个线程)去串行(如使用synchronized关键字)执行100000次&#39;++&#39;操作，和使用1个线程去执行10*100000次操作谁会更快。大家感兴趣的可以去试试，我这里就不说最后结果了。</code></p>
<h3 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h3><ul>
<li><p>synchronized的用法:<br><img src="https://s2.ax1x.com/2020/02/14/1OOBin.png" alt="synchronized"><br>synchronized可以用在方法上，也可以用在代码块上。如果锁的是类对象,尽管new出多个实例对象，但他们任然属于同一个类依然会被锁住，即线程之间保证了同步关系。</p>
</li>
<li><p>对象锁(monitor)机制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        synchronized (SynchronizedDemo.class) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有上述synchronized作用在代码块上可知，锁住的是类对象。用javap -v SynchronizedDemo.class查看字节码文件<br><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315cce259af0d2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="javap"><br>如图黄色高亮部分, 在synchronized作用于代码块之后，执行同步代码块首先要执行monitorenter指令，退出的时候执行monitorexit指令。通过分析之后可以看出，如使用synchronized进行同步，其关键是要获取对象的监控器monitor，当线程获取monitor之后才能继续向下执行，否则只能等待。且获取的过程是互斥的，同一时刻只有一个线程能获取到monitor。  </p>
<p>任意一个对象都有自己的监视器monitor,这个对象被同步方法或者同步代码块调用时，调用方的线程必须获取到该对象的监视器monitor才能进入同步块和同步方法，如果没有获取到该对象的监视器就会阻塞在同步方法或者同步代码块处，进入到block状态。  </p>
<p>对象、对象监视器、同步队列以及执行线程状态的关系<br><img src="https://user-gold-cdn.xitu.io/2018/4/30/16315cd5fa7cf91c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="monitor"><br>我们可以看出线程调用同步方法或者同步代码块的时候,必须先要获取到对象的监视器monitor,当线程获取monitor失败的时候就会进入同步队列,线程状态编程block。 当对象的monitor占有者释放后, 同步队列中的线程才有机会重新获取该对象的monitor。</p>
<ul>
<li>synchronized 和 happens-before 关系  </li>
</ul>
<p>上一篇基础篇已经介绍了JMM可以通过happens-before关系向工程师提供跨线程的内存可见性保证。那么synchronized和happens-before原则有什么关系呢？  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class MonitorDemo &#123;</span><br><span class="line"></span><br><span class="line">    private int a = 0;</span><br><span class="line"></span><br><span class="line">    public synchronized void writer() &#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void reader() &#123;</span><br><span class="line">        log.info(&quot;a:&#123;&#125;&quot;, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MonitorDemo monitorDemo = new MonitorDemo();</span><br><span class="line">        Thread thread1 = new Thread(() -&gt; &#123;monitorDemo.writer();&#125;);</span><br><span class="line">        Thread thread2 = new Thread(() -&gt; &#123;monitorDemo.reader();&#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该段代码的happens-before关系：<br><img src="https://s2.ax1x.com/2020/02/14/1Xuiod.png" alt="happen-before-1"><br>看到这里的朋友可以去试一下这段程序的执行结果以及去掉 1和4方法的synchronized关键字的执行结果。会发现加了关键字之后,始终输出结果都是 a:1。 回到该段代码的happens-before关系，黑色表示代码的顺序执行，红色是监视器monitor规则推导出来的，蓝色则是通过happens-before的传递性推导出来。所以 2happens-before5，即2的临界区代码happens-before5且2的代码是对5是内存可见的,即5读到的a的值始终都是1而不可能出现0的情况。  </p>
<ul>
<li>锁的获取和释放的内存语义<br>结合JMM的基于内存的抽象模型,来分析synchronized的语义。<br><img src="https://s2.ax1x.com/2020/02/14/1XuNOU.png" alt="JMM-1"><br>结合上述代码。从图可知, 线程A读取主存中的共享变量a=0 然后将该变量拷贝到自己的本地内存中，然后进行’++’操作，再讲a=1的值刷新回主存中。整个程序可以理解成: 线程A获取了锁–&gt; 执行了临界区代码 –&gt; 释放锁 的内存语义。</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/14/1XuBk9.png" alt="JMM-2"><br>线程B获取锁，会从主存中读取共享变量的值 a=1，然后将该值拷贝到线程B自己的工作内存中,最后释放锁的时候会将a的最新只刷新回主存中。<br>从整体上来看 线程A的操作 是对 线程B 可见的，即线程A和线程B进行了隐形通信。实现的原理为：<code>释放锁的时候会强制将值刷新回到主内存中, 其他线程获取锁的时候会强制从主存中读取最新的值</code>  </p>
<h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><p>看到这里，脑子里大概知道了synchronized是什么了吧？(别说你忘记了，感觉回忆一下)。synchronized的最大特性就是同一时刻只有一个线程能获取到对象的监视器monitor，具有互斥性(排他性)的特性。这样就能保证线程安全，但是同时也带来了性能低下的影响。 到了喜闻乐见的举栗子的环境, 我们去超时去买东西，先要去排队，排完队假如我们用现金付款，这时候收银员还需要给我们还零钱给我们，这个环境其实是十分耗时的。 但是如果我们拿出手机支付宝微信支付的话，就省去了这个找零的时候，效率就变高了。 那么回到synchronized优化的问题上，我们如果能让获取锁的实际变短，那么性能就提高咯。  </p>
<ul>
<li><p>什么是CAS<br>CAS操作想必熟悉java的多线程的工具类的同学肯定不陌生，那么你是否真的了解CAS呢？ 当使用锁的时候，线程获取锁是一种<code>悲观锁策略</code>,即会假设每一次执行临界代码的时候都会发生冲突，那么当线程获取锁的时候就会阻塞其他想获取该锁的线程。 而CAS操作是一种 <code>乐观锁</code>策略，它假设所有线程访问共享资源的时候都不会发生冲突，那么线程获取锁的时候就不会阻塞子他想获取该锁的线程，这样效率就提升了。 那么我们要考虑的是当线程发生冲突的时候怎么处理？ 那当然是CAS(compare and swap)来判断线程是否冲突，出现冲突就不断重试直到没有冲突为止。  </p>
</li>
<li><p>CAS操作过程<br>CAS(V,O,N)。 其中<code>V是内存中的值，O是旧值，N是更新的新值</code>。 然后CAS判断线程是否冲突的原理：当V和O的值相等的时候，说明该值没有被其他线程更改过，即O值就是目前主存中最新的值，这时候就可以放心的将N值赋值给V。 当V和O的值不相等的时候，说明该值在此刻已经被其他线程更改过，旧值O在主存中已经不是最新的值了，所以不能将N值赋值给V，直接返回V即可。 多个线程使用CAS操作一个变量时，只会有一个线程操作成功并更新成功，其他的程序都会失败。 失败的线程会不断去重试，也可以选择将线程挂起。  </p>
</li>
<li><p>CAS vs synchronized<br>CAS是JDK1.5后虚拟机才可以使用处理器提供的<code>CMPXCHG</code>指令实现。<br>synchronized(未优化前)的主要问题： 当存在线程竞争的时候会出现线程阻塞和唤醒锁带来的性能问题，属于阻塞同步。 而CAS使用的是乐观锁策略，CAS失败后会进行一定的重试，而不是直接将线程挂起，属于非阻塞同步。  </p>
</li>
<li><p>CAS的使用场景<br>在J.U.C包中利用CAS实现类有很多，可以说是支撑起整个concurrency包的实现，在Lock实现中会有CAS改变state变量，在atomic包中的实现类也几乎都是用CAS实现</p>
</li>
<li><p>CAS面临的问题  </p>
</li>
</ul>
<p>(1)ABA问题<br>上述很明了的说了CAS是什么，以及CAS的操作。我们回顾一下CAS的操作，CAS(V,O,N)其中通过判断V和O的值是否相等来判断该值是否被其他线程修改过。但是很有可能遇到这种场景，就是一个旧值从A 被其他线程修改成B, 又被另一个线程修改成A了。这时候只是简答的判断V=O的话，就会得出没有其他线程修改过该值的错误结论。解决方法，可以沿用数据库常用的乐观锁方式，添加一个版本号可以解决。原来的A-&gt;B-&gt;A就变成了1A-&gt;2B-&gt;3A。后续再jdk1.5版本后 atomic包就提供了AtomicStampedReference来解决ABA的问题。  </p>
<p>(2)自旋时间过久<br>CAS使用的乐观锁策略，也就是说非阻塞不会将线程挂起。但是它会自旋(不断重试, 无非就是一个死循环)进行下一次尝试，如果自旋时间过长对性能也是极大的消耗。 如果JVM能提供pause指令，那么在效率上会有一定的提升。  </p>
<p>(3)只能保证一个共享变量的原子操作<br>当值对一个共享变量进行操作的时候可以保证原子性。 如果对多个共享变量进行操作，CAS就不能保证其原子性。 不过也有解决方案，就是利用对象整合多个共享变量，然后对这个对象进行CAS操作就完美解决。atomic中提供了AtomicReference来保证引用对象之间的原子性。</p>
<ul>
<li>Java对象头<br>怎么去理解获取到对象的锁？ 即在同步的时候线程要去获取对象的监视器monitor,也就是获取对象的锁。可以将对象的锁理解成一个对象的标志，这个标志存放在对象头中。<br><code>remarks: 回顾一下JVM的知识，java对象包含三部分：对象头、实例数据、对其填充。对象头包括两部分：第一部分用于存放对象自身的运行的实例数据,如HashCode、GC年龄代、锁状态标志、线程只有的锁、偏向线程ID、偏向时间戳等。 另一部分是类型指针：对象指向它的类元数据指针，虚拟机通过这个指针来判断属于哪个对象的实例。</code>  </li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/14/1X1diQ.png" alt></p>
<p>Mark Word 会默认保存对象的hashCode、GC年龄代、锁标志状态。</p>
<p><img src="https://s2.ax1x.com/2020/02/14/1X1ss0.png" alt><br>锁一共有四种状态: <code>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</code>。 这几种状态会随竞争，<code>锁不断升级。但是锁不能降级</code>，这样就意味着偏向锁升级成轻量级锁后不能降级成偏向锁。 这种锁能升级不能降级的策略，目的是：<code>提升获取锁和释放锁的效率</code>.</p>
<ul>
<li>偏向锁<br>HotSpot虚拟机作者经过研究发现，<code>大多数情况下, 锁不仅不存在多线程竞争，而且总是同一线程多次获得，为了让线程获取锁的代价更低，故
引入了偏向锁。</code> 偏向锁针对的是单线程获取锁的场景。<br>(1)偏向锁的获取<br>当一个线程访问同步块或者同步方法获取锁的时候，会在<code>对象头和栈帧的锁记录</code>里面存储偏向线程ID，以后该线程在进入和退出同步代码块时就不需要进行CAS操作来加锁和解锁，只需要简单的测试一下<br>对象头的Mark Word里面是存储了该线程的偏向线程ID(可以理解成指向当前线程的偏向锁)。如果测试成功，就表示当前线程已经获取了该对象的偏向锁。测试失败的话，则还需再测试一下Mark Word中偏向锁<br>的标志是否设置成01(表示当前是偏向锁)，如果没有设置(则表示已经有线程占有了该对象的偏向锁)，则使用CAS竞争。如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。  </li>
</ul>
<p>(2)偏向锁的释放<br>偏向锁的机制是：<code>等到有竞争才会释放锁</code>。 所以只有的那个其他线程来竞争偏向锁的时候，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正<br>在执行的字节码）。下面用图解来更清晰的表示：<br><img src="https://s2.ax1x.com/2020/02/14/1X8U3j.png" alt="Lock-Cancel-1"><br>到了全局安全点的时候,先会暂停拥有偏向锁的线程，然后检查这些线程是否存活。如果线程没有存活，则将对象头设置成无锁状态。如果线程还存活，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，<br>栈中的锁记录和对象头的Mark Word要么偏向其他线程, 要么回复到无锁或者标记对象不合适作为偏向锁，最后唤醒线程。<br><img src="https://s2.ax1x.com/2020/02/14/1X80uq.png" alt="Lock-Cancel-2">   </p>
<p>(3)关闭偏向锁<br>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p>
<ul>
<li>轻量级锁  </li>
</ul>
<p>(1)加锁<br>线程在执行同步代码块的时候, JVM会先在当前线程的栈帧中创造存储锁记录的空间，并将对象头的Mark Word复制到锁记录空间中。官方称值为Displayed Mark Word. 然后线程尝试使用CAS将对象头的Mark Word替换为指向锁记录的指针。如果成功，当前线程获取锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁。  </p>
<p>(2)解锁<br>轻量级解锁的时候，会使用原子的CAS操作将锁记录空间的 Displayed Mark Word替换回对象头(此时对象头里面是指向锁记录的指针)。如果成功，表示没有发生竞争。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁(重量级锁是阻塞的)  </p>
<p><img src="https://s2.ax1x.com/2020/02/14/1XJ8fg.png" alt="Release-Lock"><br>因为自旋会消耗CPU，为了避免无用的自旋(比如获得锁的线程被阻塞了,会导致另一个想获取该锁的线程不断的自旋来获取这个锁)，一旦锁升级了重量级锁就不能回复成轻量级锁的状态。<br>重量级锁是阻塞的，一旦升级成重量级锁，其他线程想获取该锁都会被阻塞。当持有锁的线程释放锁后会去唤醒这些线程，被唤醒的线程又会来竞争这个临界资源。  </p>
<ul>
<li><p>各种锁比较<br><img src="https://s2.ax1x.com/2020/02/14/1XJvAf.png" alt="lock-compare"></p>
</li>
<li><p>开篇代码保证其原子性<br>看到这里的朋友不妨自己去动手将开篇的那段代码更正成线程安全的代码:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class Synchronized implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int result = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(new Synchronized());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(&quot;resutl:&#123;&#125;&quot;,result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (Synchronized.class) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="彻底理解volatile"><a href="#彻底理解volatile" class="headerlink" title="彻底理解volatile"></a>彻底理解volatile</h2><p>在synchronized一文中, 我们知道了synchronized是阻塞式同步, 在线程竞争中会自旋升级成重量级锁。而volatile就可以说是java虚拟机提供的最轻量级的同步机制。<br>回顾一下JAVA的基于共享变量的内存模型, 各个线程会从主存中读取数据并拷贝到工作内存中, 然后在各自的工作内存中进行操作。那么工作内存进行操作后何时才能写到<br>主内存中呢。对普通变量没有规定, 而volatile修饰的变量和JVM的约定, 线程对volatile变量的修改会立马被其他线程感知, 不会出现脏读现象,从而保证数据的可见性。<br><code>remarks: volatile可以保证变量的可见性，但不能保证是线程安全的。</code>  </p>
<ul>
<li>volatile 实现原理  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = new Instance() // instance是volatile变量</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>生成汇编代码的时候用volatile修饰变量就会多出一个Lock前缀的指令。 Lock前缀指令在多核处理器下会发生什么呢？<br>(1) 将当前处理器缓存行的数据写回内存。<br>(2) 这个写回操作会使其他CPU缓存了该内存地址的数据失效。  </p>
<p>在多核处理器中，为了保证各个处理器的缓存一致，就会实现<code>缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期</code>。
当处理器发现自己缓存行对应的值和总线上传播的值是不一样的，那么就说明当前处理器缓存行的内存地址被修改，就会将当前处理器的值设置成无效状态。当<br>处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p>
<p>(1)Lock指令会引起处理器缓存回写内存。<br>(2)一个处理器缓存回写内存会引起其他处理器的缓存失效(嗅探技术)<br>(3)当处理器缓存失效后，就会从内存中重新读取该数据变量,即获取最新的值。  </p>
<p>volatile机制可以保证每个线程获取到的是该变量最新的值, 但是volatile并不是原子操作。 下面进行举栗子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class VolatileDemo implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private static volatile int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            Thread thread = new Thread(new VolatileDemo());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(599); // sleep time 是我随意选的.</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;count: &#123;&#125;&quot; , count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码大家可以去跑一跑,会发现最后无论怎么执行，最后的结果都不是 200000,。 利用javap反编译上述的class文件，得出<br><img src="data:image/png;base64,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" alt></p>
<p>从反编译的图可以看出, run方法的count++ 反编译成字节码的时候变成了4行, 其中getstatic指令是吧count的值取到操作栈顶, volatile此时保证的是取到的值一定是对的。假设线程A拿了最新的值后,在执行iconst_l 和 iadd执行的时候，线程B此时已经执行完idd指令了,此时线程A拿到的值就变成了过期的数据了,所以最后通过putstatic将值同步会内存中的时候,可能就会把比实际count小的值会写进主内存了。</p>
<ul>
<li>volatile 和 happens-before 关系<br>听了我的一顿到叨叨以后,相信你已经知道了volatile可以通过<code>缓存一致性</code>来保证每个线程到的数据是最新的, 即可满足数据的<code>可见性</code>。那么我们依然从多线程的<code>两个核心、三大性质</code>来入手分析volatile关键字。 两个核心即是<code>JMM内存模型</code> 和 <code>happens-before</code>。 三大性质即 <code>原子性、可见性、有序性</code>。  
在上篇的博客中, 我们已经知道了happens-before的八大原则, 其中第三条：对一个volatile域的写happens-before 对这个域变量的读。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class VolatileExample &#123;</span><br><span class="line"></span><br><span class="line">    private int a = 0;</span><br><span class="line">    private volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        VolatileExample volatileExample = new VolatileExample();</span><br><span class="line">        Thread thread1 = new Thread(()-&gt;&#123;volatileExample.writer();&#125;);</span><br><span class="line">        Thread thread2 = new Thread(()-&gt;&#123;volatileExample.reader();&#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        if (Thread.activeCount() &gt; 1) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void writer() &#123;</span><br><span class="line">        a = 1; //1</span><br><span class="line">        flag = true; //2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void reader() &#123;</span><br><span class="line">        if (flag) &#123; //3</span><br><span class="line">            log.info(&quot;a:&#123;&#125;&quot;,a); //4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上述代码的 happens-before关系 如下图：<br><img src="https://user-gold-cdn.xitu.io/2018/5/2/16320e796b904658?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="volatile-happens-before"><br>黑色箭头表示代码顺序推导出来的, 红色是根据happens-before的第三条：对一个volatile域的写happens-before 对这个域变量的读 推导出来的,<br>蓝色部分是根据happens-before的传递性推导出来的。 这里的2happens-before 3, 即2的结果是对3是可见的。也就是说2的操作结果是立马对3是可见的,线程A将volatile变量flag更改成ture后线程B就能迅速感知。</p>
<ul>
<li>volatile 内存语义<br>上面我们已经分析了 volatile和happens-before的关系，接下来我们看那一下啊 volatile和 JMM 的关系, 分析一下volatile的内存语义。 假设线程A先执行writer方法,线程B随后执行reader方法。主内存的初始状态是 flag = false 和 a = 0。下面是volatile写后的状态图。</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/14/1XtVsA.png" alt="volatile-JMM"><br>当线程A修改了共享变量flag后，Lock指令会让处理器将flag的值回写进主内存同事让其他处理器的缓存值失效。因此线程B需要再从主内存中读取该变量的最新值。 下图就是线程B读取同一个volatile变量的内存变化示意图。<br><img src="https://s2.ax1x.com/2020/02/14/1XtMi8.png" alt="volatile-JMM"><br>横向看, 线程A和线程B就完成了一次通信。上述分别从两个核心 happens-before 和 JAVA内存模型的角度分析了 volatile关键字。    </p>
<ul>
<li>volatile 内存语义的实现<br>上篇博客讲过, 编译器和处理器为了提高性能, 会允许编译器和处理器对指令进行重排序。其中编编译器禁止对有数据依赖的操作进行重排序，处理器在将指令插入内存的时候加了内存屏障。  </li>
<li>内存屏障<br>JMM的内存屏障分成四类：<br><img src="https://s2.ax1x.com/2020/02/14/1Xt2o6.png" alt="Java-Memory-barrier"><br>java编译器会在生成指令系列时在适当的位置会插入内存屏障来禁止特定类型的处理器重排序。JMM会针对编译器制定volatile重拍系规则表：<br><img src="https://s2.ax1x.com/2020/02/14/1XthWD.png" alt="Java-Memory-barrier-2"><br>“No”表示禁止重排序。为了实现volatile内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。JMM采取的是一种保守策略来实现内存屏障:<br>(1)在每个volatile写操作的<code>前面</code>插入一个storestore屏障(禁止上面的普通写和下面的volatile写重排序)<br>(2)在每个volatile写操作的<code>后面</code>插入一个StoreLoad屏障(禁止上面的volatile写与下面可能有的volatile读/写重排序)<br>(3)在每个volatile读操作的<code>后面</code>插入一个LoadLoad屏障(禁止下面的所有普通读操作和上面的volatile的读重排序)<br>(4)在每个volatile读操作的<code>后面</code>插入一个LoadStore屏障(禁止下面的所有写普通操作和上面的volatile的读重排序)</li>
</ul>
<p>摘自<code>java并发编程艺术</code> ：<br><img src="https://s2.ax1x.com/2020/02/14/1XtjfS.png" alt="Java-Memory-barrier-3"><br><img src="https://user-gold-cdn.xitu.io/2018/5/2/16320e799b76d34c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Java-Memory-barrier-4"></p>
<ul>
<li>举个栗子  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class VolatileDemo1 &#123;</span><br><span class="line"></span><br><span class="line">  private volatile static boolean flag = false;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Thread thread = new Thread(() -&gt;</span><br><span class="line">      &#123;</span><br><span class="line">          while (!flag) &#123;</span><br><span class="line">              log.info(&quot;flag up&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">          );</span><br><span class="line">      thread.start();</span><br><span class="line">      try &#123;</span><br><span class="line">          Thread.sleep(500);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      flag = true;</span><br><span class="line">      log.info(&quot;is over&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>看到这里的朋友,可以去跑一下这个demo。会发现当mian线程将volatile flag 设置为true后, thread的工作内存的flag值立马失效,然后会从主内存中再次读取该变量的值, 也就马上退出循环了。</p>
<h2 id="你真的需要了解final"><a href="#你真的需要了解final" class="headerlink" title="你真的需要了解final"></a>你真的需要了解final</h2><h3 id="final的简介"><a href="#final的简介" class="headerlink" title="final的简介"></a>final的简介</h3><p><code>final关键字可以修饰 变量、方法、类</code>。被final修饰的内容一旦赋值就不会被改变, 比如String类就是一个finnal类型的类。(可能有小伙伴看到这里说, 小老弟你胡说, 我在开发中声明的final类型的变量就可以改变这个值呀。 这里就简单的介绍一下, String a = “hello”。 这里的 a是一个引用,指向了JVM堆区的常量池的一块内存地址X。 当修改a的值 a = “world” 后, 引用 a 会指向JVM堆区常量池的存储着”world”的内存地址。实际上这个修改a的操作并没有改变常量池中的”hello”的内存地址) 。 其中<code>final在多线程中存在的重排序问题</code>也很容易被忽略。</p>
<p><code>remarks: java7将常量池从 方法区中移到了 堆区中。</code></p>
<h3 id="final的具体使用场景"><a href="#final的具体使用场景" class="headerlink" title="final的具体使用场景"></a>final的具体使用场景</h3><p>final分别可以用作用在 变量、方法、类上。 下面分别说一下。  </p>
<ul>
<li><p>变量<br>变量可以分成两大类： 成员变量、方法中局部变量。<br>(1)final成员变量<br>成员变量又可以细分成 实例变量 和 类变量(static修饰的变量)。其中final修饰的类变量有两个赋值的时机:<code>初始化赋值的时候、静态代码块中</code>。final修饰的实例变量有三个赋值的时机: <code>初始化赋值的时候、非静态代码块中、构造函数中</code><br>(2)final局部变量<br>final修饰的具备变量必须显式初始化, 如果final局部变量已经初始化就它的值就不能再次进行修改, 即final局部编码有且只有一次赋值。  </p>
</li>
<li><p>final基本数据类型 VS final引用数据类型<br>在这篇博客的开篇就举了一个String的栗子, final修饰的引用数据类型是一个引用, 修改引用数据类型的值的时候实际上只是修改了引用指向的内存地址而并没有修改引用类型之前所指的内存地址的值。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    //在声明final实例成员变量时进行赋值</span><br><span class="line">    private final static Person person = new Person(24, 170);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //对final引用数据类型person进行更改</span><br><span class="line">        person.age = 22;</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private int age;</span><br><span class="line">        private int height;</span><br><span class="line"></span><br><span class="line">        public Person(int age, int height) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">            this.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Person&#123;&quot; +</span><br><span class="line">                    &quot;age=&quot; + age +</span><br><span class="line">                    &quot;, height=&quot; + height +</span><br><span class="line">                    &apos;&#125;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>show you code. 代码中我修改了final类型的Person对象的age的值, 是可以成功修改的 也印证了我上面所说的：当final修饰的是基本数据类型的时候，不能对基本数据类型变量重新赋值，因为此时修改的是内存地址的值。 而对引用数据类型来说的话，仅仅是一个引用，final值保证引用类型的地址不会改变。  </p>
<ul>
<li><p>方法<br>final可以修饰 变量、方法和类。 现在到了方法这部分了, 我先抛出结论：<code>被final修饰的方法, 不能被子类重写。但是可以被当前类重载。</code> 拿jdk方法中类Object来一下，如Object类的方法 getClass()方法就是final的，此时不能被子类重写的。(可以随表找一个除了Objcet的类，然后Override重写一下getClass方法, 会报错), 但是可以重写不是final修饰的方法 如 hashCode方法。</p>
</li>
<li><p>类  
还是先抛出结论：<code>当一个类被final修饰的时候，这个类是不能被子类继承的</code>。 子类继承往往可以重写父类的方法和属性，这样会带来一定的安全隐患。所以当你希望你的业务类不希望被继承的时候就用final修饰。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class FinalDemo &#123;</span><br><span class="line">  public void test() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>此时如果用 ChildFinalDemo extends FinalDemo 编译器就会提示错误：Cannot inherit from final ‘com.java.promotion.concurrent.finalDemo.FinalDemo`  </p>
<h3 id="多线程中的final关键字"><a href="#多线程中的final关键字" class="headerlink" title="多线程中的final关键字"></a>多线程中的final关键字</h3><p>来回顾一下我们在多线程中用到关键字要思考的几个点：两大核心、三大性质。两个核心是指：JMM内存模型和 happens-before重排序。 3大性质是 原子性、可见性、有序性。 这里我们队final关键字着重看一下 final域的重排序规则。  </p>
<ul>
<li>final域重排序规则<br>(1) final域为基本数据类型  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class FinalDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    private int a;  //普通域</span><br><span class="line">    private final int b; //final域</span><br><span class="line">    private static FinalDemo1 finalDemo;</span><br><span class="line"></span><br><span class="line">    public FinalDemo1() &#123;</span><br><span class="line">        a = 1; // 1. 写普通域</span><br><span class="line">        b = 2; // 2. 写final域</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        finalDemo = new FinalDemo1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reader() &#123;</span><br><span class="line">        FinalDemo1 demo = finalDemo; // 3.读对象引用</span><br><span class="line">        int a = demo.a;    //4.读普通域</span><br><span class="line">        int b = demo.b;    //5.读final域</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread1 = new Thread(() -&gt;&#123;</span><br><span class="line">            writer();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread(() -&gt;&#123;</span><br><span class="line">            reader();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>假设线程A在执行writer()方法，线程B在执行reader()方法  </p>
<ul>
<li>写final域重排序规则<br><code>写final域的重排序规则禁止final域的写重排序到构造函数之外</code>, 这个规则包括2个方面：<br>(1) JMM禁止编译器把final域的写重排序在构造函数之外<br>(2) 编译器会在final域写之后, 构造函数return之前，插入一个storestore屏障(保证final域写对其他处理器可见先于构造函数return之前,也就是这个屏障可以保证禁止处理器吧final域的写重排序到构造函数之外)。  </li>
</ul>
<p>下面我们来分析一下reader和writer方法，writer方法分两步：<br>(1)先构建了一个FinalDemo1对象<br>(2)将这个对象赋值给成员变量.<br>我们来考虑一下在多线程场景下可能执行的顺序：<br><img src="https://s2.ax1x.com/2020/02/14/1Xh4VP.png" alt="final-thread">  </p>
<p>由于操作 1、2 没有数据依赖性，所以 a = 1 可能会被处理器重排序到构造函数之外。 此时线程B读取到a的值就可能没被赋值(a=0), 这样就不合符我们的逻辑预期了。而final域的写变量是禁止重排序到构造函数之外的，所以线程B读到b的值一定是 b=2。<br>因此final域的重排序规则可以保证：在对象引用为线程可见之前，对象的final域已经被正确初始化了，而普通域并不能保证。如上述代码线程B的finaldemo可能就是一个没有被正确初始化的对象。  </p>
<p>+读final域的重排序规则<br>读final域的重排序规则为：<code>在一个线程中, 初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。</code> 处理器会在读final域前插入一个loadload屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，<br>一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。<br>read()方法主要包含了三个操作:<br>1.初次读引用变量finalDemo<br>2.初次读引用变量finaldemo的普通域a<br>3.初次读引用变量finaldemo的final域b  </p>
<p>此时可能存在以下的执行顺序：<br><img src="https://s2.ax1x.com/2020/02/14/1XhXbq.png" alt="final-thread2"><br>如果普通域的读重排序到对应引用之前，就会出错。而final域的读限制了这种可能，由loadload禁止了final域的读和对象引用的读的重排序。因此：<code>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。</code>  </p>
<p>(2)final域为引用数据类型<br>我们已经知道了final域的基本数据类型的读写在多线程中的禁止重排序的规则了。接下来我们继续来看final域的引用数据类型在多线程中的表现。  </p>
<ul>
<li>对final修饰的对象的成员域的写操作<br>针对引用类型, final域写针对编译器和处理器的重排序加了这样的约束：<code>在构造函数内对一个final修饰的对象的成员域的写入, 与随后在构造函数之外把这个被构造的对象引用赋值给一个引用变量</code>，这两个操作是禁止重排序的。举个例子来说一下会比较好懂：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceDemo &#123;</span><br><span class="line">    final int[] arrays;</span><br><span class="line">    private FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">    public FinalReferenceDemo() &#123;</span><br><span class="line">        arrays = new int[1];  //1</span><br><span class="line">        arrays[0] = 1;        //2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writerOne() &#123;</span><br><span class="line">        finalReferenceDemo = new FinalReferenceDemo(); //3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writerTwo() &#123;</span><br><span class="line">        arrays[0] = 2;  //4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (finalReferenceDemo != null) &#123;  //5</span><br><span class="line">            int temp = finalReferenceDemo.arrays[0];  //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>多线程场景下：线程A调用writerOne方法, 线程B调用wirterTwo方法, 线程C调用reader方法。<br><img src="https://s2.ax1x.com/2020/02/14/1XI3UP.png" alt="final-thread3"><br>由于对final域的写禁止重排序到构造方法外, 因此1和3不能进行重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p>
<ul>
<li><p>对final修饰的对象的成员域的读操作<br>我们继续来看线程C的reader方法。 JMM可以保证线程C至少能看到线程A对final引用的对象的成员域的写入, 即arrays[0] = 1 , 而线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见,<br>线程B和吸纳成C之间存在数据竞争,此时结果是不可预知的。 如果想要达成可见，可以用锁或者volatile(思路：执行屏障)  </p>
</li>
<li><p>final重排序的总结<br>按照我们博客所说的内容, 思路是先将final修饰的分成 基本类型 和 引用类型。 在对各个类型的 final写和 final读进行分析。<br>(1)基本数据类型  </p>
</li>
<li><p>final域写：禁止final域写和构造方法重排序, 即禁止final域写重排序到构造方法之外,实现原理是在final域写后面加上storestore屏障。从而保证该对象对所有线程可见，该对象的final域已经全部初始化过。</p>
</li>
<li><p>final域读:禁止初次读对象的引用 和 读对象包含的final域 的重排序。  </p>
</li>
</ul>
<p>(2)引用数据类型<br>额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序.</p>
<ul>
<li>final的实现原理<br>上面我们提到过，<code>写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。</code><br><code>remarks:很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器</code>  </li>
</ul>
<h3 id="为什么final引用不能从构造函数中”逸出”"><a href="#为什么final引用不能从构造函数中”逸出”" class="headerlink" title="为什么final引用不能从构造函数中”逸出”"></a>为什么final引用不能从构造函数中”逸出”</h3><p>我们已经知道了, final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是也有一个前提：``在构造函数中, 不能让这个被构造的函数的对象被其他线程可见, 也就是说该对象的引用不能在构造函数中”逸出”。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceEscapeDemo &#123;</span><br><span class="line">    private final int a;</span><br><span class="line">    private FinalReferenceEscapeDemo referenceDemo;</span><br><span class="line"></span><br><span class="line">    public FinalReferenceEscapeDemo() &#123;</span><br><span class="line">        a = 1;  //1</span><br><span class="line">        referenceDemo = this; //2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeDemo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (referenceDemo != null) &#123;  //3</span><br><span class="line">            int temp = referenceDemo.a; //4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能出现的执行顺序:<br><img src="https://user-gold-cdn.xitu.io/2018/5/2/16320f7de16b0ec0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="final-thread4"><br>由于1和2没有数据依赖关系, 1和2可能进行了重排序，先执行了2。 这个时候引用对象referenceDemo是个没有完全初始化的对象(final变量没有初始化)，此时线程B去读就会报错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">OnOne</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://nooneblog.com/2019/10/15/并发编程熟练掌握--并发关键字/">https://nooneblog.com/2019/10/15/并发编程熟练掌握--并发关键字/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-concurrency/">java-concurrency</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/10/26/并发编程熟练掌握--lock体系之AQS详解/"><i class="fa fa-chevron-left">  </i><span>并发编程熟练掌握--lock体系详解之AQS</span></a></div><div class="next-post pull-right"><a href="/2019/10/12/新轻量级熔断技术 --Sentinel/"><span>新轻量级熔断技术选型--Sentinel源码解析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By OnOne</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://nooneblog.com/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>