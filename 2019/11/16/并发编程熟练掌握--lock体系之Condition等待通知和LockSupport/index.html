<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="并发编程熟练掌握--Lock体系详解之Condition的await和signal等待/通知机制和LockSupport工具"><meta name="keywords" content="java-concurrency"><meta name="author" content="OnOne"><meta name="copyright" content="OnOne"><title>并发编程熟练掌握--Lock体系详解之Condition的await和signal等待/通知机制和LockSupport工具 | NoOneBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程熟练掌握–Lock体系详解之Condition等待-通知和LockSupport和LockSupport工具"><span class="toc-number">1.</span> <span class="toc-text">并发编程熟练掌握–Lock体系详解之Condition等待/通知和LockSupport和LockSupport工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition简介"><span class="toc-number">2.</span> <span class="toc-text">Condition简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition的API"><span class="toc-number">2.1.</span> <span class="toc-text">Condition的API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition实现原理分析"><span class="toc-number">3.</span> <span class="toc-text">Condition实现原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等待队列"><span class="toc-number">3.1.</span> <span class="toc-text">等待队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await实现原理"><span class="toc-number">3.2.</span> <span class="toc-text">await实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#signal-signalAll实现原理"><span class="toc-number">4.</span> <span class="toc-text">signal/signalAll实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#await-signal的思考"><span class="toc-number">4.1.</span> <span class="toc-text">await/signal的思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await-signal的实例"><span class="toc-number">4.2.</span> <span class="toc-text">await/signal的实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport工具"><span class="toc-number">5.</span> <span class="toc-text">LockSupport工具</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560457003474&amp;di=6832c808a533625921e698bee88bbdb0&amp;imgtype=0&amp;src=http%3A%2F%2Fimg08.oneniceapp.com%2Fupload%2Favatar%2F2018%2F05%2F05%2Faba7e29327a27abfcb1e525f623934ee.jpg"></div><div class="author-info__name text-center">OnOne</div><div class="author-info__description text-center">Happiness is only real when shared!</div><div class="follow-button"><a href="https://github.com/ahang9524">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NoOneBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">并发编程熟练掌握--Lock体系详解之Condition的await和signal等待/通知机制和LockSupport工具</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技能树/">技能树</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="并发编程熟练掌握–Lock体系详解之Condition等待-通知和LockSupport和LockSupport工具"><a href="#并发编程熟练掌握–Lock体系详解之Condition等待-通知和LockSupport和LockSupport工具" class="headerlink" title="并发编程熟练掌握–Lock体系详解之Condition等待/通知和LockSupport和LockSupport工具"></a>并发编程熟练掌握–Lock体系详解之Condition等待/通知和LockSupport和LockSupport工具</h2><h2 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h2><p>说到等待通知机制,相比所有人都会想到Object对象中的wait() 和 notify() 以及 notifyAll() 方法, 而java所有的类都继承与Objcet类,<br>所以可以通过继承Object的 wait 和 notify 方法来完成等待通知。 同样的在Lock体系汇总依然可以实现等待通知机制。而这两者的区别在于<br><code>Object方式的wait/notify是与对象监视器来配合完成线程间的等待/通知机制的, 而Condition是与Lock配合完成的等待通知机制。前者是java
底层,后者是语言级别的具有更好的扩展性</code>两者在使用上不同外, 还在功能上有如下不同:<br>1.Conditon能够支持不响应中断, 而通过使用Object方式不支持<br>2.Conditon能够支持多个等待队列, Object中能支持一个<br>3.Condition能够支持超时时间设置, 而Objcet不支持</p>
<h3 id="Condition的API"><a href="#Condition的API" class="headerlink" title="Condition的API"></a>Condition的API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void await() throws InterruptedException:当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；</span><br><span class="line">long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时；</span><br><span class="line">boolean await(long time, TimeUnit unit)throws InterruptedException：同第二种，支持自定义时间单位</span><br><span class="line">boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间</span><br><span class="line"></span><br><span class="line">void signal()：唤醒一个等待在condition上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。</span><br><span class="line">void signalAll()：与1的区别在于能够唤醒所有等待在condition上的线程</span><br></pre></td></tr></table></figure>

<h2 id="Condition实现原理分析"><a href="#Condition实现原理分析" class="headerlink" title="Condition实现原理分析"></a>Condition实现原理分析</h2><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>本篇依旧是通过源码来看原理。创建一个condition对象是通过lock.newCondition(),这个方法实际上会new出一个ConditionObject的对象,通过源码我们可以知道该类是AQS的一个内部类。condition要配合lock来使用来实现等待/通知机制, 而Lock同步语义的实现又十分依赖于AQS。在上两节我对lock的了解,知道了lock的同步队列(双向链表且带头结点,以及指向头尾的指针)。如果获取锁失败会通过尾插法插到同步队列中, 同样condition维护了一个等待队列, 所有调用Condtion.await方法的线程都会加入到等待队列中，并且线程的状态编程等待状态。<br>通过conditionObject的源码我们可以知道其数据结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** First node of condition queue. */</span><br><span class="line">private transient Node firstWaiter;</span><br><span class="line">/** Last node of condition queue. */</span><br><span class="line">private transient Node lastWaiter;</span><br></pre></td></tr></table></figure>

<p>通过源码我们可以知道ConditionObject有指向头尾的指针,其中Node是复用了AQS的Node类。继续跟进看Node源码我们发现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">      * Link to next node waiting on condition, or the special</span><br><span class="line">      * value SHARED.  Because condition queues are accessed only</span><br><span class="line">      * when holding in exclusive mode, we just need a simple</span><br><span class="line">      * linked queue to hold nodes while they are waiting on</span><br><span class="line">      * conditions. They are then transferred to the queue to</span><br><span class="line">      * re-acquire. And because conditions can only be exclusive,</span><br><span class="line">      * we save a field by using special value to indicate shared</span><br><span class="line">      * mode.</span><br><span class="line">      */</span><br><span class="line">     Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>AQS哪一篇博客中我们已经知道了Node里面的状态和同步队列的前驱和后继节点。然后这里的 nextWaitrer表示的是在等待队列中的后继节点。<br><code>那也就可以看出等待队列是一个单向队列。</code>在等待队列的介绍中说到，lock可以new出多个conditionObject对象，那么先给出多个conditon的示意图<br>然后我们来攻克源码。<br><img src="https://s2.ax1x.com/2020/02/16/3pe4cn.png" alt><br>ConditionObject是AQS的内部类,因此conditionObject能够访问AQS提供的方法,相当于Condition都拥有所属同步器的引用。</p>
<h3 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h3><p>`当调用conditon.await方法后会是获取到了lock锁的线程进入到等待队列中, 如果该线程能改从await方法返回的话那么一定是获取到了与condition关联的lock``，先说了结论下面我们来分析源码了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Implements interruptible condition wait.</span><br><span class="line">         * &lt;ol&gt;</span><br><span class="line">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span><br><span class="line">         * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;.</span><br><span class="line">         * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument,</span><br><span class="line">         *      throwing IllegalMonitorStateException if it fails.</span><br><span class="line">         * &lt;li&gt; Block until signalled or interrupted.</span><br><span class="line">         * &lt;li&gt; Reacquire by invoking specialized version of</span><br><span class="line">         *      &#123;@link #acquire&#125; with saved state as argument.</span><br><span class="line">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span><br><span class="line">         * &lt;/ol&gt;</span><br><span class="line">*/</span><br><span class="line">        public final void await() throws InterruptedException &#123;</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">                //1. 将当前线程包装成Node，并尾插等待等待队列中</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">                //2.释放当前线程的lock,并唤醒同步队列中的下一个节点</span><br><span class="line">            int savedState = fullyRelease(node);</span><br><span class="line">            int interruptMode = 0;</span><br><span class="line">            while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              //3. 当前线程进入等待状态</span><br><span class="line">                LockSupport.park(this);  </span><br><span class="line">                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">                break;</span><br><span class="line">           &#125;</span><br><span class="line">                //4. 自旋获取同步状态</span><br><span class="line">            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            if (interruptMode != 0)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过源码以及关键注释可以知道，当调用了Conditon.await方法后，当前线程会包装成Node节点加入到等待队列<br>中并且释放锁，直到被signal/signalAll唤醒从等待队列移到同步队列中。那么我们来看三个细节：<br>1.将当前线程尾插到等待队列中的细节.<br>2.释放锁的细节<br>3.怎么从await方法返回<br>show me the code :  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 1.将当前线程尾插到等待队列中的细节</span><br><span class="line">*/</span><br><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    // If lastWaiter is cancelled, clean out.</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">	//将当前线程包装成Node</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">		//尾插入</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">	//更新lastWaiter</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码很容易看出尾插到等待队列的细节：将当前线程包装成Node，当等待队列为空的时候，firstWaiter指针就<br>指向了node，否则就用尾节点指向node(也就是尾插法)。<code>等待队列是一个不带头结点的链式结构，且通过尾插法加入等待队列</code>.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 2.释放锁的细节</span><br><span class="line">   * Invokes release with current state value; returns saved state.</span><br><span class="line">   * Cancels node and throws exception on failure.</span><br><span class="line">   * @param node the condition node for this wait</span><br><span class="line">   * @return previous sync state</span><br><span class="line">   */</span><br><span class="line">  final int fullyRelease(Node node) &#123;</span><br><span class="line">      boolean failed = true;</span><br><span class="line">      try &#123;</span><br><span class="line">          int savedState = getState();</span><br><span class="line">          if (release(savedState)) &#123;</span><br><span class="line">            // 释放同步状态成功</span><br><span class="line">              failed = false;</span><br><span class="line">              return savedState;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 释放同步状态失败则抛出异常</span><br><span class="line">              throw new IllegalMonitorStateException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          if (failed)</span><br><span class="line">              node.waitStatus = Node.CANCELLED;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>源码及注释很容易看出释放锁的细节: AQS的模板方法release()会释放当前同步状态并且唤醒同步队列中头结点的后续节点。释放成功的话就正常返回失败则抛出异常并且将当前节点的等待状态设置成取消。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 怎么从await方法返回  </span><br><span class="line">*/</span><br><span class="line">while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">  //3. 当前线程进入等待状态</span><br><span class="line">    LockSupport.park(this);  </span><br><span class="line">    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Returns true if a node, always one that was initially placed on</span><br><span class="line">     * a condition queue, is now waiting to reacquire on sync queue.</span><br><span class="line">     * @param node the node</span><br><span class="line">     * @return true if is reacquiring</span><br><span class="line">     */</span><br><span class="line">    final boolean isOnSyncQueue(Node node) &#123;</span><br><span class="line">        if (node.waitStatus == Node.CONDITION || node.prev == null)</span><br><span class="line">            return false;</span><br><span class="line">        if (node.next != null) // If has successor, it must be on queue</span><br><span class="line">            return true;</span><br><span class="line">        /*</span><br><span class="line">         * node.prev can be non-null, but not yet on queue because</span><br><span class="line">         * the CAS to place it on queue can fail. So we have to</span><br><span class="line">         * traverse from tail to make sure it actually made it.  It</span><br><span class="line">         * will always be near the tail in calls to this method, and</span><br><span class="line">         * unless the CAS failed (which is unlikely), it will be</span><br><span class="line">         * there, so we hardly ever traverse much.</span><br><span class="line">         */</span><br><span class="line">        return findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看源码可知从await方法返回有两种方式：<br>1.程序走到break退出.即线程被中断<br>2.while循环中的值为false,即isOnSyncQueue为ture。即节点从等待队列移动到同步队列中，也就是该线程<br>被signal/signalAll唤醒从等待队列中移动到同步队列中。回到await方法的源码中来，我们继续看从while循环退出后的代码。 acquireQueued(node, savedState) 是使用了AQS的模板方法,通过自旋来获取同步状态。<code>也就是非中断方式从await方法返回必须是获取到condtion关联的lock</code><br><img src="https://s2.ax1x.com/2020/02/16/3pej39.png" alt="condition-await"><br>调用await方法线程必须是获取到了锁的。如果该线程是同步队列中的头结点，那么调用conditon.await方法后会尾插到等到队列中。<br><code>remarks：另超时等待机制可以去看awaitNanos,awaitUtil方法，大致原理相同。不响应中断condition.awaitUninterruptibly()的源码原理大致相同。</code>  </p>
<h2 id="signal-signalAll实现原理"><a href="#signal-signalAll实现原理" class="headerlink" title="signal/signalAll实现原理"></a>signal/signalAll实现原理</h2><p><code>Conditon.signal/signalAll 方法可以将等待队列中等待时间最长的节点(队列的属性可知是头结点)移动到同步队列中</code><br>show me the code :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">    * Moves the longest-waiting thread, if one exists, from the</span><br><span class="line">    * wait queue for this condition to the wait queue for the</span><br><span class="line">    * owning lock.</span><br><span class="line">    *</span><br><span class="line">    * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125;</span><br><span class="line">    *         returns &#123;@code false&#125;</span><br><span class="line">    */</span><br><span class="line">   public final void signal() &#123;</span><br><span class="line">     //判断线程是否获取到锁</span><br><span class="line">       if (!isHeldExclusively())</span><br><span class="line">           throw new IllegalMonitorStateException();</span><br><span class="line">       Node first = firstWaiter;</span><br><span class="line">       //获取等待队列中的首节点</span><br><span class="line">       if (first != null)</span><br><span class="line">           doSignal(first);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="line">     * null. Split out from signal in part to encourage compilers</span><br><span class="line">     * to inline the case of no waiters.</span><br><span class="line">     * @param first (non-null) the first node on condition queue</span><br><span class="line">     */</span><br><span class="line">    private void doSignal(Node first) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">                lastWaiter = null;</span><br><span class="line">            first.nextWaiter = null;</span><br><span class="line">            //transferForSignal做处理逻辑。将节点从等待队列中移到同步队列中</span><br><span class="line">        &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                 (first = firstWaiter) != null);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line"> * Transfers a node from a condition queue onto sync queue.</span><br><span class="line"> * Returns true if successful.</span><br><span class="line"> * @param node the node</span><br><span class="line"> * @return true if successfully transferred (else the node was</span><br><span class="line"> * cancelled before signal)</span><br><span class="line"> */</span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">     */</span><br><span class="line">     //cas将Node(线程)状态设置成0。如果失败则说明该节点被 cancelled</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">     * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">     * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">     * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">     */</span><br><span class="line">     //将节点放进同步队列中，尾插法(AQS模板方法)</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码和注释可知，将线程节点从等待队列移到同步队列的核心逻辑在transferForSignal方法中。这个方法<br>主要做了两件事儿：<br>1.将头结点的的状态更改为condition<br>2.调用enq()将节点入同步队列  </p>
<p>通过分析完singal源码可知。调用conditon.signal/signalAll方法的线程先要获取到锁,该方法会使等待队列中的头结点移动到同步队列的尾节点中,而移动到同步队列中的节点才有机会呗唤醒。也就是await源码中的while循环中的LockSupport.unpark返回，这样才有机会从await方法中返回。signal示意图：<br><img src="https://s2.ax1x.com/2020/02/16/3pmwUU.png" alt="condition-signal">  </p>
<p>signalAll方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void doSignalAll(Node first) &#123;</span><br><span class="line">    lastWaiter = firstWaiter = null;</span><br><span class="line">    do &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; while (first != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道了signal方法的原理后,signalAll方法就是遍历等待队列中的节点，然后调用transferForSignal方法。  </p>
<h3 id="await-signal的思考"><a href="#await-signal的思考" class="headerlink" title="await/signal的思考"></a>await/signal的思考</h3><p>通过本篇博客以及源码分析,lock通过await/signal来实现了等待通知机制。这种等待通知机制可以用来解决生产者消费者的问题。下面用图来展示<br><img src="https://s2.ax1x.com/2020/02/16/3pmyvR.png" alt="conditon-await-signal"></p>
<p>通过上图可以看出, awaitThread获取到锁后,通过调用conditon.await()方法是释放锁并且进入等待队列中。另一个线程signalThread方法获取到锁后调用conditon.signal/signalAll方法, 使await线程从等待队列移动到同步队列中去。当其他获取到锁的线程释放锁后使得await线程获取到锁, 在非中断的情况下只有线程获取到锁后才能才await方法返回执行后续操作。如果awaitThread获取锁失败会直接进入同步队列。  </p>
<h3 id="await-signal的实例"><a href="#await-signal的实例" class="headerlink" title="await/signal的实例"></a>await/signal的实例</h3><p>直接上代码了：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.ahang.promotion.condition;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class AwaitSignalDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    private static volatile boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread awaitThread = new Thread(new AwaitThread());</span><br><span class="line">        Thread signalThread = new Thread(new SignalThread());</span><br><span class="line">        awaitThread.start();</span><br><span class="line">        signalThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class AwaitThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println( Thread.currentThread().getName() + &quot;当前线程不满足等待状态&quot;);</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;当前线程被唤醒&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class SignalThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;开始唤醒线程&quot;);</span><br><span class="line">                condition.signalAll();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;唤醒线程完成&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console result:</span><br><span class="line">Thread-0当前线程不满足等待状态</span><br><span class="line">Thread-1开始唤醒线程</span><br><span class="line">Thread-1唤醒线程完成</span><br><span class="line">Thread-0当前线程被唤醒</span><br></pre></td></tr></table></figure>

<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>通过Lock篇的博客, 在我们看源码的过程中发现了有LockSupport的park和unpark方法。lockSupport是阻塞的原语，可以用来阻塞和唤醒线程。<br>相关API方法可以了解一下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">阻塞线程：</span><br><span class="line">1.void park()：阻塞当前线程，如果调用 unpark 方法或者当前线程被中断，从能从 park()方法中返回</span><br><span class="line">2.void park(Object blocker)：功能同方法 1，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</span><br><span class="line">3.void parkNanos(long nanos)：阻塞当前线程，最长不超过 nanos 纳秒，增加了超时返回的特性；</span><br><span class="line">4.void parkNanos(Object blocker, long nanos)：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</span><br><span class="line">5.void parkUntil(long deadline)：阻塞当前线程，知道 deadline；</span><br><span class="line">6.void parkUntil(Object blocker, long deadline)：功能同方法 5，入参增加一个 Object 对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">唤醒线程：</span><br><span class="line">void unpark(Thread thread):唤醒处于阻塞状态的指定线程</span><br></pre></td></tr></table></figure>

<p><code>remarks：synchronized 和 LockSupport.park的区别: synchronized会使线程阻塞,线程的状态变成blocked状态，LockSupport.park方法也会使线程阻塞,而线程状态变成Waitting</code></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">OnOne</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://nooneblog.com/2019/11/16/并发编程熟练掌握--lock体系之Condition等待通知和LockSupport/">https://nooneblog.com/2019/11/16/并发编程熟练掌握--lock体系之Condition等待通知和LockSupport/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-concurrency/">java-concurrency</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/11/23/并发容器之ConcurrentHashMap详解/"><i class="fa fa-chevron-left">  </i><span>并发编程熟练掌握--并发容器之ConcurrentHashMap详解(JDK1.8)</span></a></div><div class="next-post pull-right"><a href="/2019/11/09/并发编程熟练掌握--lock体系详解之ReentrantLock、ReentrantReadWriteLock详解/"><span>并发编程熟练掌握--lock体系详解之ReentrantLock、ReentrantReadWriteLock详解</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By OnOne</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://nooneblog.com/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>