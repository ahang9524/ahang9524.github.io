<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="并发编程熟练掌握--并发容器之ConcurrentHashMap详解(JDK1.8)"><meta name="keywords" content="java-concurrency"><meta name="author" content="OnOne"><meta name="copyright" content="OnOne"><title>并发编程熟练掌握--并发容器之ConcurrentHashMap详解(JDK1.8) | NoOneBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程熟练掌握–并发编程熟练掌握–并发容器之ConcurrentHashMap详解-JDK1-8"><span class="toc-number">1.</span> <span class="toc-text">并发编程熟练掌握–并发编程熟练掌握–并发容器之ConcurrentHashMap详解(JDK1.8)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么并发场景下要选择ConcurrentHashMap"><span class="toc-number">2.</span> <span class="toc-text">为什么并发场景下要选择ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键属性"><span class="toc-number">2.1.</span> <span class="toc-text">关键属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心方法"><span class="toc-number">3.</span> <span class="toc-text">核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">3.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initTable方法"><span class="toc-number">3.2.</span> <span class="toc-text">initTable方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put方法"><span class="toc-number">3.3.</span> <span class="toc-text">put方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get方法"><span class="toc-number">3.4.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transfer方法"><span class="toc-number">3.5.</span> <span class="toc-text">transfer方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size相关方法"><span class="toc-number">3.6.</span> <span class="toc-text">size相关方法</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560457003474&amp;di=6832c808a533625921e698bee88bbdb0&amp;imgtype=0&amp;src=http%3A%2F%2Fimg08.oneniceapp.com%2Fupload%2Favatar%2F2018%2F05%2F05%2Faba7e29327a27abfcb1e525f623934ee.jpg"></div><div class="author-info__name text-center">OnOne</div><div class="author-info__description text-center">Happiness is only real when shared!</div><div class="follow-button"><a href="https://github.com/ahang9524">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">23</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NoOneBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">并发编程熟练掌握--并发容器之ConcurrentHashMap详解(JDK1.8)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技能树/">技能树</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="并发编程熟练掌握–并发编程熟练掌握–并发容器之ConcurrentHashMap详解-JDK1-8"><a href="#并发编程熟练掌握–并发编程熟练掌握–并发容器之ConcurrentHashMap详解-JDK1-8" class="headerlink" title="并发编程熟练掌握–并发编程熟练掌握–并发容器之ConcurrentHashMap详解(JDK1.8)"></a>并发编程熟练掌握–并发编程熟练掌握–并发容器之ConcurrentHashMap详解(JDK1.8)</h2><h2 id="为什么并发场景下要选择ConcurrentHashMap"><a href="#为什么并发场景下要选择ConcurrentHashMap" class="headerlink" title="为什么并发场景下要选择ConcurrentHashMap"></a>为什么并发场景下要选择ConcurrentHashMap</h2><p>1.HashMap: 说到HashMap相必大家肯定都很熟练的使用过了,如果不熟悉的同学推荐看程序员小灰漫画将算法里面写的很清楚(非广告)。HashMap是非线程安全的,在并发场景下HashMap的Entry链表会可能会形成环状结构,一旦形成环状结构Entry的节点的next就永不为空程序就不会退出,还会导致CPU飙高。所以hashMap并不适合于并发场景。  </p>
<p>2.HashTable：这时候你可能会想到HashTable,但是hashtable的内部实现大量的使用了synchronized来做线程安全的控制，而我们在前几篇的博客中了解到了synchronized是独占锁,并发场景下只要一个线程能获取到对象的监控器(monitor),显然效率太低下，基本不适合工业界的并发场景。  </p>
<p>3.SynchronzedMap: 有的同学可能还了解一种数据结构，SynchronzedMap也是线程安全的，但是这个方法的实现只是在HashMap的基础上封装了一层，在封装的方法里面加synchronized关键字来实现线程安全，效率方面也比较低。  </p>
<p>这时候就出现了一种很优秀的ConcurrentHashMap。ConcurrentHashMap在jdk1.8版本前使用了segment分段来控制线程安全, jdk1.8版本之前的ConcurrentHashMap在本篇blog中不做详细介绍, 本篇重点还是放在JDK1.8b版本的ConcurrentHashMap的原理和实现上来说。<br>到了JDk1.8版本，ConcurrentHashMap舍弃了segment分段的思想，并且通过大量的synchronized和cas保证了线程安全。采用synchronized而不是ReentrantLock 原因是synchronized做了很多的优化,包括偏向锁、轻量级锁、重量级锁, 支持升级但是不支持降级。底层数据结构采用的是 数组 + 链表 + 红黑树。  </p>
<p>这里先给出java8舍弃分段锁的原因的结论：<br>1.生产环境中ConcurrentHashMap放入数据时竞争同一锁的概率非常低，分段锁反而会导致更新操作长时间等待。<br>2.提高了性能。使用粒度更新的node,锁住node而不是segment。<br>3.加入分段锁浪费了内存空间。<br>4.为了提高GC的效率。  </p>
<h3 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h3><p>话不多说，开撸源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* ConcurrentHashMap的关键 fileds</span><br><span class="line">*/</span><br><span class="line">/* ---------------- Fields -------------- */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The array of bins. Lazily initialized upon first insertion.</span><br><span class="line">     * Size is always a power of two. Accessed directly by iterators.</span><br><span class="line">     */</span><br><span class="line">    transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The next table to use; non-null only while resizing.</span><br><span class="line">     */</span><br><span class="line">    private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Base counter value, used mainly when there is no contention,</span><br><span class="line">     * but also as a fallback during table initialization</span><br><span class="line">     * races. Updated via CAS.</span><br><span class="line">     */</span><br><span class="line">    private transient volatile long baseCount;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Table initialization and resizing control.  When negative, the</span><br><span class="line">     * table is being initialized or resized: -1 for initialization,</span><br><span class="line">     * else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">     * when table is null, holds the initial table size to use upon</span><br><span class="line">     * creation, or 0 for default. After initialization, holds the</span><br><span class="line">     * next element count value upon which to resize the table.</span><br><span class="line">     */</span><br><span class="line">    private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The next table index (plus one) to split while resizing.</span><br><span class="line">     */</span><br><span class="line">    private transient volatile int transferIndex;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span><br><span class="line">     */</span><br><span class="line">    private transient volatile int cellsBusy;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Table of counter cells. When non-null, size is a power of 2.</span><br><span class="line">     */</span><br><span class="line">    private transient volatile CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>

<p>上述源码是concurrentHashMap的fileds属性。注释给的太给力了，这里就不做描述了，建议仔细看一遍fileds的源码注释会对理解起来很有帮助。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* ConcurrentHashMap的内部类</span><br><span class="line">* Node主要继承Map.Entry, 且val和next用volatile修饰保障了内存可见性</span><br><span class="line">*/  </span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       final int hash;</span><br><span class="line">       final K key;</span><br><span class="line">       volatile V val;</span><br><span class="line">       volatile Node&lt;K,V&gt; next;</span><br><span class="line">       ···</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Nodes for use in TreeBins</span><br><span class="line">    * 继承Node</span><br><span class="line">    */</span><br><span class="line">   static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">       TreeNode&lt;K,V&gt; left;</span><br><span class="line">       TreeNode&lt;K,V&gt; right;</span><br><span class="line">       TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">       boolean red;</span><br><span class="line">       ···</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  /* ---------------- TreeBins -------------- */</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 红黑树的操作是针对TreeBins类的</span><br><span class="line">    * TreeNodes used at the heads of bins. TreeBins do not hold user</span><br><span class="line">    * keys or values, but instead point to list of TreeNodes and</span><br><span class="line">    * their root. They also maintain a parasitic read-write lock</span><br><span class="line">    * forcing writers (who hold bin lock) to wait for readers (who do</span><br><span class="line">    * not) to complete before tree restructuring operations.</span><br><span class="line">    */</span><br><span class="line">   static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; root;</span><br><span class="line">       volatile TreeNode&lt;K,V&gt; first;</span><br><span class="line">       volatile Thread waiter;</span><br><span class="line">       volatile int lockState;</span><br><span class="line">       // values for lockState</span><br><span class="line">       static final int WRITER = 1; // set while holding write lock</span><br><span class="line">       static final int WAITER = 2; // set when waiting for write lock</span><br><span class="line">       static final int READER = 4; // increment value for setting read lock</span><br><span class="line">       ···</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">  /* ---------------- Special Nodes -------------- */</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 在扩容时才会出现的特殊节点。其key,value,hash 全部为 null。并拥有 nextTable 指针引用新的 table 数组</span><br><span class="line">    * A node inserted at head of bins during transfer operations.</span><br><span class="line">    */</span><br><span class="line">   static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">       final Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">       ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">           super(MOVED, null, null, null);</span><br><span class="line">           this.nextTable = tab;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16</span><br><span class="line">ConcurrentHashMap()</span><br><span class="line">// 2. 给定map的大小</span><br><span class="line">ConcurrentHashMap(int initialCapacity)</span><br><span class="line">// 3. 给定一个map</span><br><span class="line">ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br><span class="line">// 4. 给定map的大小以及加载因子</span><br><span class="line">ConcurrentHashMap(int initialCapacity, float loadFactor)</span><br><span class="line">// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）</span><br><span class="line">ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)</span><br></pre></td></tr></table></figure>

<p>我们继续跟进看2的构造函数的实现  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Creates a new, empty map with an initial table size</span><br><span class="line">     * accommodating the specified number of elements without the need</span><br><span class="line">     * to dynamically resize.</span><br><span class="line">     *</span><br><span class="line">     * @param initialCapacity The implementation performs internal</span><br><span class="line">     * sizing to accommodate this many elements.</span><br><span class="line">     * @throws IllegalArgumentException if the initial capacity of</span><br><span class="line">     * elements is negative</span><br><span class="line">     */</span><br><span class="line">    public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">      //1. initialCapacity 小于0 则抛出异常</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">            //2.initialCapacity容量大于了可允许的最大值取最大值,否则调用tableSizeFor  </span><br><span class="line">        int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line">        this.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段源码配合关键部分注释很容易知道这是要确定 sizeCtl即ConcurrentHashMap的大小的。前面是对参数initialCapacity做了一个正负和是否超出允许范围的判断。 下面我们继续跟进看一下tableSizeFor   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a power of two table size for the given desired capacity.</span><br><span class="line">     * See Hackers Delight, sec 3.2</span><br><span class="line">     */</span><br><span class="line">    private static final int tableSizeFor(int c) &#123;</span><br><span class="line">        int n = c - 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 2;</span><br><span class="line">        n |= n &gt;&gt;&gt; 4;</span><br><span class="line">        n |= n &gt;&gt;&gt; 8;</span><br><span class="line">        n |= n &gt;&gt;&gt; 16;</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过注释和源码我们很清楚的知道了，tableSizeFor是为了将传参的C最终转换成一个2的幂次方返回。且规律举例：如果传入的c=28，为了满足2的幂次方的特点，即2^5 = 32 &gt; 28 ,即最终会返回32。<br><code>remarks: 通过构造函数我们的注意一点，构造函数里面并没有直接创建一个ConcurrentHashMap的容器，而是初始化了ConcurrentHashMap的大小，利用了lazy-init的思想</code>  </p>
<h3 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Initializes table, using the size recorded in sizeCtl.</span><br><span class="line">    */</span><br><span class="line">   private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">       while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">           if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">               //1. 保证只有一个线程初始化。 sizeCtl字段定义看上述源码注释</span><br><span class="line">               Thread.yield(); // lost initialization race; just spin</span><br><span class="line">           else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                     //2 得出数组的大小</span><br><span class="line">                       int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                       //3 数组初始化</span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       // 4. 数组的可用大小。 这段代码相当于 n*0,75(0.75是默认的负载因子)</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>源码+注释我们很清楚知道了, ConcurrentHashMap做初始化的时候，只能有1个线程进行初始化，通过Thread.yield让出了线程获取到的CPU时间片。通过CAS来讲sizeCtl值设置成-1(表示有线程正在初始化)。然后执行初始化过程的时候才创建了ConcurrentHasMap的容器。且容器的初始化可用大小为 n * 0.75。</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/** Implementation for put and putIfAbsent */</span><br><span class="line">    final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">        //1. 计算key的对应hash值</span><br><span class="line">        int hash = spread(key.hashCode());</span><br><span class="line">        int binCount = 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            //2. table没有初始化的话，进调用initTable进行初始化(lazy-init)</span><br><span class="line">            if (tab == null || (n = tab.length) == 0)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">              //3.当table的索引i为空的时候，通过casTabAt将值插入</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                    break;                   // no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            //4.正在扩容</span><br><span class="line">            else if ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal = null;</span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                      //5.当前为链表，在链表中进行插入键值对</span><br><span class="line">                        if (fh &gt;= 0) &#123;</span><br><span class="line">                            binCount = 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    if (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                if ((e = e.next) == null) &#123;</span><br><span class="line">                                    pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123;</span><br><span class="line">                          //6.当前为红黑树，在红黑树中插入键值对</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = 2;</span><br><span class="line">                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != null) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //7. 键值对插入完毕后，看容器大小判断是否需要将链表转换成红黑树</span><br><span class="line">                if (binCount != 0) &#123;</span><br><span class="line">                  //8. TREEIFY_THRESHOLD = 8</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal != null)</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //8 对当前容器大小进行判断看是否需要扩容</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过源码和注释我们知道了ConcurrentHashMap是通过CAS和synchronized来保证线程安全的，synchronized锁住的只是链表中插入键值对那部分逻辑。<br><img src="https://s2.ax1x.com/2020/02/16/3pKxPO.png" alt="concurrentHashMap"><br>如图我们知道ConcurrentHashMap是一个哈希桶数组,使用的是链地址法解决哈希冲突。通过源码我们可以知道为了防止hash冲突时性能下降,当容器size&gt;8的时候,将会将链表转换成红黑树。当插入键值对时首先应该定位到要插入的桶，即插入 table 数组的索引 i 处。而索引i是通过计算key的hash值得出的。   </p>
<p>我们在思考一下注释中的几个标识点：<br>3: 能否直接将值插入到table数组中?<br>先根据key的hash值与数组长度取模找到table数组中的索引i, 如果索引i的table数组为null的话就能直接插入。用cas保证线程安全。  </p>
<p>4.怎么判断当前线程是否在进行扩容操作？<br>我们可以看看上面concurrentHashMap的fields字段中的内部类ForwardingNode(只有扩容才会出现的特殊节点)。所以通过下面这个if就能判断当前线程是否在扩容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((fh = f.hash) == MOVED) 中的 MOVED = static final int MOVED = -1; // hash for forwarding nodes.</span><br></pre></td></tr></table></figure>

<p>5.链表中插入新值<br>当 table[i]为链表的头结点，在链表中插入新值。通过synchronized保证线程安全，主要逻辑是 是否有hash值相同的key，有的话就覆盖没有的话就尾插到链表中。  </p>
<p>6.红黑树插入新值<br>当 table[i]为红黑树的根节点，在红黑树中插入新值。核心插入逻辑也是在红黑树种找是否有hash值相同的key，有点话就覆盖没有的话就插入。  </p>
<p>7.链表转红黑树<br>通过链地址法解决hash冲突的时候,为了防止性能下降。当链表长度大于等于8的时候会将链表转换成红黑树。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (binCount != 0) &#123;</span><br><span class="line">    if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    if (oldVal != null)</span><br><span class="line">        return oldVal;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>show me the code：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns the value to which the specified key is mapped,</span><br><span class="line">     * or &#123;@code null&#125; if this map contains no mapping for the key.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span><br><span class="line">     * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code key.equals(k)&#125;,</span><br><span class="line">     * then this method returns &#123;@code v&#125;; otherwise it returns</span><br><span class="line">     * &#123;@code null&#125;.  (There can be at most one such mapping.)</span><br><span class="line">     *</span><br><span class="line">     * @throws NullPointerException if the specified key is null</span><br><span class="line">     */</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        //1.计算key的hash值。 重hash</span><br><span class="line">        int h = spread(key.hashCode());</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">              //table[i]桶节点的值和要查找的key值相同，则直接返回</span><br><span class="line">            if ((eh = e.hash) == h) &#123;</span><br><span class="line">                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前节点的hash值小于0说明是树节点，在红黑树中查找</span><br><span class="line">            else if (eh &lt; 0)</span><br><span class="line">                return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">            while ((e = e.next) != null) &#123;</span><br><span class="line">              //在链表中查找</span><br><span class="line">                if (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>get方法就很好理解了。先通过hash定位到哈希桶table[i]，看hash桶的值是否和key相同。相同的话直接返回、不相同的话通过判断是链表还是红黑树然后在其中查找。  </p>
<h3 id="transfer方法"><a href="#transfer方法" class="headerlink" title="transfer方法"></a>transfer方法</h3><p>当concurrentHashMap容量不足的时候就需要对ConcurrentHashMap进行扩容, 扩容的核心逻辑就在transfer方法中。直接来看源码了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Moves and/or copies the nodes in each bin to new table. See</span><br><span class="line">    * above for explanation.</span><br><span class="line">    */</span><br><span class="line">   private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">       int n = tab.length, stride;</span><br><span class="line">       if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">           stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">           //1.扩容 n&lt;&lt;1 即新建一个2n大小的Node数组</span><br><span class="line">       if (nextTab == null) &#123;            // initiating</span><br><span class="line">           try &#123;</span><br><span class="line">               @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">               Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">               nextTab = nt;</span><br><span class="line">           &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">               sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           nextTable = nextTab;</span><br><span class="line">           transferIndex = n;</span><br><span class="line">       &#125;</span><br><span class="line">       int nextn = nextTab.length;</span><br><span class="line">       //2. 新建 ForwardingNode 引用</span><br><span class="line">       ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">       boolean advance = true;</span><br><span class="line">       boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">       for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int fh;</span><br><span class="line">           //3. 确认遍历中的索引i</span><br><span class="line">           while (advance) &#123;</span><br><span class="line">               int nextIndex, nextBound;</span><br><span class="line">               if (--i &gt;= bound || finishing)</span><br><span class="line">                   advance = false;</span><br><span class="line">               else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                   i = -1;</span><br><span class="line">                   advance = false;</span><br><span class="line">               &#125;</span><br><span class="line">               else if (U.compareAndSwapInt</span><br><span class="line">                        (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                         nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                      nextIndex - stride : 0))) &#123;</span><br><span class="line">                   bound = nextBound;</span><br><span class="line">                   i = nextIndex - 1;</span><br><span class="line">                   advance = false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //4. 将原数组的中的数据挪动到2n的数组中。并重置sizeCtl——&gt;1.5倍扩容</span><br><span class="line">           if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">               int sc;</span><br><span class="line">               if (finishing) &#123;</span><br><span class="line">                   nextTable = null;</span><br><span class="line">                   table = nextTab;</span><br><span class="line">                   sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                   if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                       return;</span><br><span class="line">                   finishing = advance = true;</span><br><span class="line">                   i = n; // recheck before commit</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //5.当前数组第i的位置为空，用cas设置成null。</span><br><span class="line">           else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">               advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">              //6 如果遍历到ForwardingNode节点  说明这个点已经被处理过了 直接跳过  这里是控制并发扩容的核心</span><br><span class="line">           else if ((fh = f.hash) == MOVED)</span><br><span class="line">               advance = true; // already processed</span><br><span class="line">           else &#123;</span><br><span class="line">               synchronized (f) &#123;</span><br><span class="line">                   if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                       if (fh &gt;= 0) &#123;</span><br><span class="line">                         //7. fh &gt;=0 表示是链表。处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表  另一个是原链表的反序排列</span><br><span class="line">                           int runBit = fh &amp; n;</span><br><span class="line">                           Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                           for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                               int b = p.hash &amp; n;</span><br><span class="line">                               if (b != runBit) &#123;</span><br><span class="line">                                   runBit = b;</span><br><span class="line">                                   lastRun = p;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           if (runBit == 0) &#123;</span><br><span class="line">                               ln = lastRun;</span><br><span class="line">                               hn = null;</span><br><span class="line">                           &#125;</span><br><span class="line">                           else &#123;</span><br><span class="line">                               hn = lastRun;</span><br><span class="line">                               ln = null;</span><br><span class="line">                           &#125;</span><br><span class="line">                           for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                               int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                               if ((ph &amp; n) == 0)</span><br><span class="line">                                   ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                               else</span><br><span class="line">                                   hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                           &#125;</span><br><span class="line">                            //在nextTable的i位置上插入一个链表</span><br><span class="line">                           setTabAt(nextTab, i, ln);</span><br><span class="line">                           // //在nextTable的i+n的位置上插入另一个链表</span><br><span class="line">                           setTabAt(nextTab, i + n, hn);</span><br><span class="line">                           ////在table的i位置上插入forwardNode节点  表示已经处理过该节点</span><br><span class="line">                           setTabAt(tab, i, fwd);</span><br><span class="line">                            //设置advance为true 返回到上面的while循环中 就可以执行i--操作</span><br><span class="line">                           advance = true;</span><br><span class="line">                       &#125;</span><br><span class="line">                       else if (f instanceof TreeBin) &#123;</span><br><span class="line">                         //8 处理当前节点是红黑树时的情况，操作和上面的类似</span><br><span class="line">                           TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                           TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                           TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                           int lc = 0, hc = 0;</span><br><span class="line">                           for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                               int h = e.hash;</span><br><span class="line">                               TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                   (h, e.key, e.val, null, null);</span><br><span class="line">                               if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                   if ((p.prev = loTail) == null)</span><br><span class="line">                                       lo = p;</span><br><span class="line">                                   else</span><br><span class="line">                                       loTail.next = p;</span><br><span class="line">                                   loTail = p;</span><br><span class="line">                                   ++lc;</span><br><span class="line">                               &#125;</span><br><span class="line">                               else &#123;</span><br><span class="line">                                   if ((p.prev = hiTail) == null)</span><br><span class="line">                                       hi = p;</span><br><span class="line">                                   else</span><br><span class="line">                                       hiTail.next = p;</span><br><span class="line">                                   hiTail = p;</span><br><span class="line">                                   ++hc;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                           ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                               (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                           hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                               (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                           setTabAt(nextTab, i, ln);</span><br><span class="line">                           setTabAt(nextTab, i + n, hn);</span><br><span class="line">                           setTabAt(tab, i, fwd);</span><br><span class="line">                           advance = true;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>transfer源码有点长，配着我写的注释一起看就能了解到transfer的主要核心思想了。 我们来总结一下几个核心步骤：<br>1.构建一个nextTable，容量为原来的两倍.<br>2.将sizeCtz也扩容两倍。位运算实现的(n &lt;&lt; 1) - (n &gt;&gt;&gt; 1), 性能更高。<br>3.将table中的数据复制到nextTable中。遍历过程先根据数组的i通过tabAt找到对应的元素再判断：<br>1)如果这个元素为null，则放入forwardNode，这个是控制并发扩容的关键。<br>2)通过fh&gt;=0为链表，fh &lt; 0 为红黑树。思路都是构建一个反序的链表/红黑树放在nexttable的i和i+n的位置处。<br><img src="https://s2.ax1x.com/2020/02/16/3pMkZt.png" alt="transfer">  </p>
<h3 id="size相关方法"><a href="#size相关方法" class="headerlink" title="size相关方法"></a>size相关方法</h3><p>最后我们来看一下ConcurrentHashMap是怎么计算实际容量大小的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns the number of mappings. This method should be used</span><br><span class="line">    * instead of &#123;@link #size&#125; because a ConcurrentHashMap may</span><br><span class="line">    * contain more mappings than can be represented as an int. The</span><br><span class="line">    * value returned is an estimate; the actual count may differ if</span><br><span class="line">    * there are concurrent insertions or removals.</span><br><span class="line">    *</span><br><span class="line">    * @return the number of mappings</span><br><span class="line">    * @since 1.8</span><br><span class="line">    */</span><br><span class="line">   public long mappingCount() &#123;</span><br><span class="line">       long n = sumCount();</span><br><span class="line">       return (n &lt; 0L) ? 0L : n; // ignore transient negative values</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">final long sumCount() &#123;</span><br><span class="line">            CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">            //1. baseCount =</span><br><span class="line">            long sum = baseCount;</span><br><span class="line">            if (as != null) &#123;</span><br><span class="line">                for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">                    if ((a = as[i]) != null)</span><br><span class="line">                        sum += a.value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释上来看, 官方推荐使用mappingSize而不是size方法。且mappingSize返回的是一个大概的值，因为在统计的时候有其他线程进行插入或者删除 ;(插个题外话,GC进行可达性分析的时候有STW操作)  </p>
<p>我们在插入数据的时候,需要对concurrentHashMap的容器数量+1,具体逻辑我们继续撸源码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Adds to count, and if table is too small and not already</span><br><span class="line">    * resizing, initiates transfer. If already resizing, helps</span><br><span class="line">    * perform transfer if work is available.  Rechecks occupancy</span><br><span class="line">    * after a transfer to see if another resize is already needed</span><br><span class="line">    * because resizings are lagging additions.</span><br><span class="line">    *</span><br><span class="line">    * @param x the count to add</span><br><span class="line">    * @param check if &lt;0, don&apos;t check resize, if &lt;= 1 only check if uncontended</span><br><span class="line">    */</span><br><span class="line">   private final void addCount(long x, int check) &#123;</span><br><span class="line">       CounterCell[] as; long b, s;</span><br><span class="line">       //1.利用CAS更新baseCount的值</span><br><span class="line">       if ((as = counterCells) != null ||</span><br><span class="line">           !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">           CounterCell a; long v; int m;</span><br><span class="line">           boolean uncontended = true;</span><br><span class="line">           if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">               (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">               !(uncontended =</span><br><span class="line">                 U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">               fullAddCount(x, uncontended);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           if (check &lt;= 1)</span><br><span class="line">               return;</span><br><span class="line">           s = sumCount();</span><br><span class="line">       &#125;</span><br><span class="line">       //2检查是否需要扩容</span><br><span class="line">       if (check &gt;= 0) &#123;</span><br><span class="line">           Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">           while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">                  (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               int rs = resizeStamp(n);</span><br><span class="line">               if (sc &lt; 0) &#123;</span><br><span class="line">                   if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                       sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                       transferIndex &lt;= 0)</span><br><span class="line">                       break;</span><br><span class="line">                       //3如果有其他线程正在扩容</span><br><span class="line">                   if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                       transfer(tab, nt);</span><br><span class="line">               &#125;</span><br><span class="line">               //4当前线程是一个发起扩容的线程, 此时nextTable = null</span><br><span class="line">               else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                   transfer(tab, null);</span><br><span class="line">               s = sumCount();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们可以知道addCount主要做了2件事儿 ：<br>1.cas对baseCount进行+1<br>2.检查是否需要扩容</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">OnOne</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://nooneblog.com/2019/11/23/并发容器之ConcurrentHashMap详解/">https://nooneblog.com/2019/11/23/并发容器之ConcurrentHashMap详解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-concurrency/">java-concurrency</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/11/30/并发编程熟练掌握--并发容器之ConcurrentLinkedQueue详解(JDK1.8)/"><i class="fa fa-chevron-left">  </i><span>并发编程熟练掌握--并发容器之ConcurrentLinkedQueue详解</span></a></div><div class="next-post pull-right"><a href="/2019/11/16/并发编程熟练掌握--lock体系之Condition等待通知和LockSupport/"><span>并发编程熟练掌握--Lock体系详解之Condition的await和signal等待/通知机制和LockSupport工具</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By OnOne</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://nooneblog.com/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>