<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="并发编程熟练掌握--并发容器之ThreadLocal详解"><meta name="keywords" content="java-concurrency"><meta name="author" content="OnOne"><meta name="copyright" content="OnOne"><title>并发编程熟练掌握--并发容器之ThreadLocal详解 | NoOneBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发编程熟练掌握–并发编程熟练掌握–并发容器之ThreadLocal详解"><span class="toc-number">1.</span> <span class="toc-text">并发编程熟练掌握–并发编程熟练掌握–并发容器之ThreadLocal详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-简介"><span class="toc-number">2.</span> <span class="toc-text">ThreadLocal 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal实现原理"><span class="toc-number">3.</span> <span class="toc-text">ThreadLocal实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set方法"><span class="toc-number">3.1.</span> <span class="toc-text">set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get方法"><span class="toc-number">3.2.</span> <span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove方法"><span class="toc-number">3.3.</span> <span class="toc-text">remove方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一探ThreadLocalMap"><span class="toc-number">4.</span> <span class="toc-text">一探ThreadLocalMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Entry数据结构"><span class="toc-number">4.1.</span> <span class="toc-text">Entry数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set方法-1"><span class="toc-number">4.2.</span> <span class="toc-text">set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getEntry方法"><span class="toc-number">4.3.</span> <span class="toc-text">getEntry方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove方法-1"><span class="toc-number">4.4.</span> <span class="toc-text">remove方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal的实际应用场景"><span class="toc-number">5.</span> <span class="toc-text">ThreadLocal的实际应用场景</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560457003474&amp;di=6832c808a533625921e698bee88bbdb0&amp;imgtype=0&amp;src=http%3A%2F%2Fimg08.oneniceapp.com%2Fupload%2Favatar%2F2018%2F05%2F05%2Faba7e29327a27abfcb1e525f623934ee.jpg"></div><div class="author-info__name text-center">OnOne</div><div class="author-info__description text-center">Happiness is only real when shared!</div><div class="follow-button"><a href="https://github.com/ahang9524">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">NoOneBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">并发编程熟练掌握--并发容器之ThreadLocal详解</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-07</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技能树/">技能树</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="并发编程熟练掌握–并发编程熟练掌握–并发容器之ThreadLocal详解"><a href="#并发编程熟练掌握–并发编程熟练掌握–并发容器之ThreadLocal详解" class="headerlink" title="并发编程熟练掌握–并发编程熟练掌握–并发容器之ThreadLocal详解"></a>并发编程熟练掌握–并发编程熟练掌握–并发容器之ThreadLocal详解</h2><h2 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h2><p>通过前面几篇博客我们知道使用lock或synchronized在并发场景下访问共享资源,从而解决线程安全的问题。这种方式<br>是通过锁的方式来控制多个线程对临界资源的访问。同事java还提供了一种思路<code>空间换时间</code>,ThreadLocal表示每个线程<br>的“本地变量”,每个变量都拥有该变量副本,从而达到不用去竞争“共享资源”。<br><code>remarks: ThreadLocal并不是java.lock.concurrent包下的,而是java.lang.ThreadLocal</code>  </p>
<h2 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h2><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Sets the current thread&apos;s copy of this thread-local variable</span><br><span class="line">     * to the specified value.  Most subclasses will have no need to</span><br><span class="line">     * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">     * method to set the values of thread-locals.</span><br><span class="line">     *</span><br><span class="line">     * @param value the value to be stored in the current thread&apos;s copy of</span><br><span class="line">     *        this thread-local.</span><br><span class="line">     */</span><br><span class="line">    public void set(T value) &#123;</span><br><span class="line">      //1.获取当前线程</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        //2.获取当前线程的 ThreadLocalMap</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null)</span><br><span class="line">        //3.map存在就插入</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">        //4.不存在就新建一个ThreadLocalMap</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>set方法的主逻辑很简单,先获取到当前操作线程的实例,然后获取到实例的ThreadLocalMap,存在的话就插入,<br>不存在的话就新建一个线程。同时我们注意到了,ThreadLocal的key是当前ThraedLocal实例。<br><code>remarks: 我们先来看ThreadLocal的主要方法。本篇博客后面会详细解析ThreadLocalMap的。</code>  </p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Returns the value in the current thread&apos;s copy of this</span><br><span class="line">    * thread-local variable.  If the variable has no value for the</span><br><span class="line">    * current thread, it is first initialized to the value returned</span><br><span class="line">    * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">    *</span><br><span class="line">    * @return the current thread&apos;s value of this thread-local</span><br><span class="line">    */</span><br><span class="line">   public T get() &#123;</span><br><span class="line">     //1.获取当前线程的实例</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       //2.得到当前线程的ThreadLocalMap</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       //3.Map不为空且Entry不为空则返回值</span><br><span class="line">       if (map != null) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">           if (e != null) &#123;</span><br><span class="line">               @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //4.Map为空或者Entry为空则初始化</span><br><span class="line">       return setInitialValue();</span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">  * Variant of set() to establish initialValue. Used instead</span><br><span class="line">  * of set() in case user has overridden the set() method.</span><br><span class="line">  *</span><br><span class="line">  * @return the initial value</span><br><span class="line">  */</span><br><span class="line"> private T setInitialValue() &#123;</span><br><span class="line">     T value = initialValue();</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     if (map != null)</span><br><span class="line">         map.set(this, value);</span><br><span class="line">     else</span><br><span class="line">         createMap(t, value);</span><br><span class="line">     return value;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> protected T initialValue() &#123;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从get源码和注释中,我们可以很清晰的知道取值的逻辑。同时要注意一点的是在初始化的时候设置T value的值的方法initialValue() 使用protected修饰的,也就是说ThreadLocal的子类可以重写这个方法。  </p>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">        //1.获取当前线程的ThreadLocalMap</span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        if (m != null)</span><br><span class="line">        //2.从map中删除以自己为key的键值对</span><br><span class="line">            m.remove(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="一探ThreadLocalMap"><a href="#一探ThreadLocalMap" class="headerlink" title="一探ThreadLocalMap"></a>一探ThreadLocalMap</h2><p>我们先来看源码中关于ThreadLoclMap的注释以及包含的属性字段。ThreadLocalMap是ThreadLocal的静态内部类。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * ThreadLocalMap is a customized hash map suitable only for</span><br><span class="line">     * maintaining thread local values. No operations are exported</span><br><span class="line">     * outside of the ThreadLocal class. The class is package private to</span><br><span class="line">     * allow declaration of fields in class Thread.  To help deal with</span><br><span class="line">     * very large and long-lived usages, the hash table entries use</span><br><span class="line">     * WeakReferences for keys. However, since reference queues are not</span><br><span class="line">     * used, stale entries are guaranteed to be removed only when</span><br><span class="line">     * the table starts running out of space.</span><br><span class="line">     */</span><br><span class="line">    static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * The entries in this hash map extend WeakReference, using</span><br><span class="line">         * its main ref field as the key (which is always a</span><br><span class="line">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><br><span class="line">         * == null) mean that the key is no longer referenced, so the</span><br><span class="line">         * entry can be expunged from table.  Such entries are referred to</span><br><span class="line">         * as &quot;stale entries&quot; in the code that follows.</span><br><span class="line">         */</span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            /** The value associated with this ThreadLocal. */</span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * The initial capacity -- MUST be a power of two.</span><br><span class="line">         */</span><br><span class="line">        private static final int INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * The table, resized as necessary.</span><br><span class="line">         * table.length MUST always be a power of two.</span><br><span class="line">         */</span><br><span class="line">        private Entry[] table;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * The number of entries in the table.</span><br><span class="line">         */</span><br><span class="line">        private int size = 0;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * The next size value at which to resize.</span><br><span class="line">         */</span><br><span class="line">        private int threshold; // Default to 0</span><br><span class="line">        ···</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Entry数据结构"><a href="#Entry数据结构" class="headerlink" title="Entry数据结构"></a>Entry数据结构</h3><p>从源码中我们知道了 Entry[] table 容量大小是2的幂次方以及它的内部结构是 以ThreadLocal为key,Object 为value的数据结构。从源码注释中可以知道Entry是一个弱引用。</p>
<p>ThreadLocal的内存泄漏思考：<br><img src="https://s2.ax1x.com/2020/02/16/3pMcWD.png" alt="Entry"><br>图中实线表示强引用,虚线表示弱引用。如图所示,Thread可以通过threadLocal找到对应的ThreadLocalMap。上述源码我们已知ThreadLoaclMap是以ThreadLocal为key,Object为value的键值对。需要主要的是Entry的key是弱引用,当ThreadLocal在外部被设置成null的时候,jvm在进行gc的时候根据可达性分析就没办法找到ThreadLocal,那么ThreadLocal就会被回收。这样就会在ThreadLocalMap中出现key为空的键值对,key为空那么就没办法找到对应的value。当线程迟迟不结束的时候，就会出现大量的key为空的entry。这些entry中会一直存在一条强引用链Thread-&gt;ThreadLocal-&gt;ThreaLocalMap-&gt;Entry-&gt;value,从而造成内存泄漏。<br>这时候有的同学可能想到当线程结束被回收的时候,ThreadLocal就没有引用链了,这样Entry中的value值也能被回收啦。 但是实际生产中我们在使用线程池的时候,很有可能会使用固定的线程池,线程为了复用不会主动结束。这样就会出现上述的内存泄漏的问题。  </p>
<h3 id="set方法-1"><a href="#set方法-1" class="headerlink" title="set方法"></a>set方法</h3><p>ThreadLocalMap采用的是散列表,其中解决hash冲突的方式是开放寻址法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">         * Set the value associated with key.</span><br><span class="line">         *</span><br><span class="line">         * @param key the thread local object</span><br><span class="line">         * @param value the value to be set</span><br><span class="line">         */</span><br><span class="line">        private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">            // We don&apos;t use a fast path as with get() because it is at</span><br><span class="line">            // least as common to use set() to create new entries as</span><br><span class="line">            // it is to replace existing ones, in which case, a fast</span><br><span class="line">            // path would fail more often than not.</span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line">            //1.根据ThreadLocal的hash值来获取到entry的位置</span><br><span class="line">            int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">            //2.使用开放寻址法来解决hash冲突</span><br><span class="line">            for (Entry e = tab[i];</span><br><span class="line">                 e != null;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                //3.已存在就直接覆盖</span><br><span class="line">                if (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                //4. k== null 也就是我们上面内存泄漏的思考中提到的。ThreadLocal在外部被</span><br><span class="line">                设置成空。再通过当前的key去获取value就会造成内存泄漏</span><br><span class="line">                if (k == null) &#123;</span><br><span class="line">                  //5.用当前插入的值替换掉这个key为null的“脏”entry</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //5.没有hash冲突的时候就新建entry放在i位置</span><br><span class="line">            tab[i] = new Entry(key, value);</span><br><span class="line">            int sz = ++size;</span><br><span class="line">            //6.插入后再做一次清楚key为null的 slots。 并检查是否需要扩容。</span><br><span class="line">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码写的可很精彩。上面我们说道了关于ThreadLocal会产生的内存泄漏的问题。在ThreadLocalMap中的set方法中对内存泄漏做了优化。set方法中在存在hash冲突的时候且出现了ThreadLocal为空,此时通过replaceStaleEntry方法将key为null的“脏”entry给替换掉。以及在插入新的tab[i]的时候做了一次清楚key为null的“脏”entry操作。  </p>
<p>我们来继续看一下ThreadLocalMap是如何做扩容操作的：<br>由源码注释可知：ThreadLocalMap的初始大小为16,负载因子为2/3,即初始可用容量为10.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">        * Double the capacity of the table.</span><br><span class="line">        */</span><br><span class="line">       private void resize() &#123;</span><br><span class="line">           Entry[] oldTab = table;</span><br><span class="line">           int oldLen = oldTab.length;</span><br><span class="line">           int newLen = oldLen * 2;</span><br><span class="line">           //1. 双倍扩容</span><br><span class="line">           Entry[] newTab = new Entry[newLen];</span><br><span class="line">           int count = 0;</span><br><span class="line"></span><br><span class="line">           for (int j = 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">               Entry e = oldTab[j];</span><br><span class="line">               if (e != null) &#123;</span><br><span class="line">                   ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                   //2 遍历过程中发现k==null的时候,就将value置空。防止内存泄漏</span><br><span class="line">                   if (k == null) &#123;</span><br><span class="line">                       e.value = null; // Help the GC</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       int h = k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                       while (newTab[h] != null)</span><br><span class="line">                           h = nextIndex(h, newLen);</span><br><span class="line">                       newTab[h] = e;</span><br><span class="line">                       count++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           setThreshold(newLen);</span><br><span class="line">           size = count;</span><br><span class="line">           table = newTab;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>在resize的时候也做了防止内存泄漏的优化。遍历旧的Entry发现key为空就将对于的value置空。  </p>
<h3 id="getEntry方法"><a href="#getEntry方法" class="headerlink" title="getEntry方法"></a>getEntry方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">	//1. 确定在散列数组中的位置</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">	//2. 根据索引i获取entry</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">	//3. 满足条件则返回该entry</span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">		//4. 未查找到满足条件的entry，额外在做的处理</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">while (e != null) &#123;</span><br><span class="line">    ThreadLocal&amp;lt;?&amp;gt; k = e.get();</span><br><span class="line">    if (k == key)</span><br><span class="line">		//找到和查询的key相同的entry则返回</span><br><span class="line">        return e;</span><br><span class="line">    if (k == null)</span><br><span class="line">		//解决脏entry的问题</span><br><span class="line">        expungeStaleEntry(i);</span><br><span class="line">    else</span><br><span class="line">		//继续向后环形查找</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">    e = tab[i];</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细分析了set方法后再来看getEntry方法就很容易理解了。这里说一下getEntry对防止内存泄漏而做的优化。如果找到相同的key就返回,如果key == null则用expungeStaleEntry解决“脏”值。</p>
<h3 id="remove方法-1"><a href="#remove方法-1" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Remove the entry for key.</span><br><span class="line"> */</span><br><span class="line">private void remove(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        if (e.get() == key) &#123;</span><br><span class="line">			//将entry的key置为null</span><br><span class="line">            e.clear();</span><br><span class="line">			//将该entry的value也置为null</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove操作先用clear操作将key设置成空，然后用expungeStaleEntry将value置空。  </p>
<h2 id="ThreadLocal的实际应用场景"><a href="#ThreadLocal的实际应用场景" class="headerlink" title="ThreadLocal的实际应用场景"></a>ThreadLocal的实际应用场景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.ahang.promotion.concurrent;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            executor.submit(new DateFormatThread(&quot;2019-12-05 09:00:&quot; + i % 60));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class DateFormatThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String date;</span><br><span class="line"></span><br><span class="line">        public DateFormatThread(String date) &#123;</span><br><span class="line">            this.date = date;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (threadLocal.get() == null) &#123;</span><br><span class="line">                threadLocal.set(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                    Date date = threadLocal.get().parse(this.date);</span><br><span class="line">                    System.out.println(date);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用ThreadLocal解决了SimpleFormateDate在并发场景下的线程不安全问题 且 性能高。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">OnOne</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://nooneblog.com/2019/12/07/并发编程熟练掌握--并发容器之ThreadLocal详解/">https://nooneblog.com/2019/12/07/并发编程熟练掌握--并发容器之ThreadLocal详解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java-concurrency/">java-concurrency</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/12/14/并发编程熟练掌握--线程池之ScheduledThreadPoolExecutor/"><i class="fa fa-chevron-left">  </i><span>并发编程熟练掌握--线程池之ScheduledThreadPoolExecutor</span></a></div><div class="next-post pull-right"><a href="/2019/11/30/并发编程熟练掌握--并发容器之ConcurrentLinkedQueue详解(JDK1.8)/"><span>并发编程熟练掌握--并发容器之ConcurrentLinkedQueue详解</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/md/wallhaven-md1x69.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By OnOne</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://nooneblog.com/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>